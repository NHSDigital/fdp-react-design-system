{
  "version": 3,
  "sources": ["../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/types.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/constants.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/utils.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/limits.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/detector.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/conflict.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/assurance.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/trendSegments.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/visualCategories.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/boundaryWindows.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/engine.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/presets.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/preprocess.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/retroOverlay.ts"],
  "sourcesContent": ["// Strongly-typed enums and core types mirroring SQL v2.6a naming.\n// These names are chosen to be easy to cross-reference with the SQL script and docs.\n\n// Supported chart types \u2014 v2.6a parity focuses on XmR; T and G can be added as needed\nexport enum ChartType {\n\tXmR = \"XmR\",\n\tT = \"T\",\n\tG = \"G\",\n}\n\n// How a metric is judged: higher is better, lower is better, or neither (neutral)\nexport enum ImprovementDirection {\n\tUp = \"Up\",\n\tDown = \"Down\",\n\tNeither = \"Neither\",\n}\n\n// Variation icon classification used for testing parity against SQL.\n// SQL v2.6a emits icons only for the last point, but we retain a per-row value for convenience.\nexport enum VariationIcon {\n\tImprovementHigh = \"ImprovementHigh\", // improvement on the high side (metric Up)\n\tImprovementLow = \"ImprovementLow\", // improvement on the low side (metric Down)\n\tConcernHigh = \"ConcernHigh\", // concern on the high side (metric Down)\n\tConcernLow = \"ConcernLow\", // concern on the low side (metric Up)\n\tNeitherHigh = \"NeitherHigh\", // neutral with a high-side special cause for Neither metrics\n\tNeitherLow = \"NeitherLow\", // neutral with a low-side special cause for Neither metrics\n\tCommonCause = \"CommonCause\", // no special cause detected contributing to icon\n}\n\n// Assurance outcome relative to target and process limits (XmR only in this module)\nexport enum AssuranceIcon {\n\tNone = \"None\",\n\tPass = \"Pass\",\n\tHitOrMiss = \"HitOrMiss\",\n\tFail = \"Fail\",\n}\n\n// Identifiers for rule types used in ranking and diagnostics\nexport enum SpcRuleId {\n\tSinglePoint = \"SinglePoint\",\n\tTwoSigma = \"TwoSigma\",\n\tShift = \"Shift\",\n\tTrend = \"Trend\",\n}\n\n// Direction determined by comparing the strongest rule rank on each side\nexport enum PrimeDirection {\n\tUpwards = \"Upwards\",\n\tDownwards = \"Downwards\",\n\tSame = \"Same\",\n}\n\n// Convenience to describe which side of the mean a signal sits on\nexport enum Side {\n\tUp = \"Up\",\n\tDown = \"Down\",\n}\n\n// Policy to apply when PrimeDirection is Same and both candidates exist\nexport enum MetricConflictRule {\n\tImprovement = \"Improvement\",\n\tConcern = \"Concern\",\n}\n\n// Strategy for resolving conflicts when both improvement and concern candidates exist\nexport enum ConflictStrategy {\n\t// Maintain SQL v2.6a parity: use PrimeDirection first, then MetricConflictRule only when PrimeDirection is Same\n\tSqlPrimeThenRule = \"SqlPrimeThenRule\",\n\t// Excel-style: always prefer the improvement side when a conflict exists (ignores PrimeDirection)\n\tPreferImprovement = \"PreferImprovement\",\n\t// Custom rule hierarchy: choose the side that contains the highest-precedence rule from a provided order\n\tRuleHierarchy = \"RuleHierarchy\",\n}\n\n// Strategy to select which mean-side trend segment(s) participate after splitting a run at crossings - integral for special cause conflict resolution\nexport enum TrendSegmentationStrategy {\n\t// Highlight all favourable-side segments\n\tFavourableSide = \"FavourableSide\",\n\t// Highlight the first favourable-side segment that occurs after a crossing; if no crossing occurred,\n\t// fall back to the longest favourable-side segment (by length)\n\tCrossingAfterFavourable = \"CrossingAfterFavourable\",\n\t// Highlight the favourable-side segment with the greatest absolute distance from mean\n\tExtremeFavourable = \"ExtremeFavourable\",\n\t// Always pick the first favourable-side segment in the run (chronological)\n\tFirstFavourable = \"FirstFavourable\",\n\t// Pick the longest favourable-side segment by length (ties broken by earliest)\n\tLongestFavourable = \"LongestFavourable\",\n\t// Pick the last favourable-side segment in the run (chronological)\n\tLastFavourable = \"LastFavourable\",\n\t// Unfavourable variants \u2014 mirror the above but for the opposite mean side\n\tUnfavourableSide = \"UnfavourableSide\",\n\t// Highlight the first unfavourable-side segment that occurs after a crossing; if no crossing occurred, fall back to the longest unfavourable-side segment (by length)\n\tCrossingAfterUnfavourable = \"CrossingAfterUnfavourable\",\n\t// Highlight the unfavourable-side segment with the greatest absolute distance from mean\n\tExtremeUnfavourable = \"ExtremeUnfavourable\",\n\t// Always pick the first unfavourable-side segment in the run (chronological)\n\tFirstUnfavourable = \"FirstUnfavourable\",\n\t// Pick the longest unfavourable-side segment by length (ties broken by earliest)\n\tLongestUnfavourable = \"LongestUnfavourable\",\n\t// Pick the last unfavourable-side segment in the run (chronological)\n\tLastUnfavourable = \"LastUnfavourable\",\n}\n\n// Controls when favourable trend segmentation should apply\nexport enum TrendSegmentationMode {\n\t// Do not apply segmentation at all\n\tOff = \"Off\",\n\t// Apply segmentation automatically only when a conflict is detected in the series/partition\n\tAutoWhenConflict = \"AutoWhenConflict\",\n\t// Always apply segmentation regardless of conflicts (legacy boolean=true behaviour)\n\tAlways = \"Always\",\n}\n\n// The input row shape accepted by the engine\nexport interface SpcInputRowV2 {\n\tx: string | number | Date;\n\tvalue?: number | null;\n\tghost?: boolean;\n\tbaseline?: boolean;\n\ttarget?: number | null;\n}\n\n// Settings that influence rule thresholds and pruning behaviour\nexport interface SpcSettingsV26a {\n\tminimumPoints?: number; // global gating\n\tshiftPoints?: number; // default 6\n\ttrendPoints?: number; // default 6\n\texcludeMovingRangeOutliers?: boolean; // default false\n\tmetricConflictRule?: MetricConflictRule; // default Improvement\n\t// Parity-specific controls\n\ttrendAcrossPartitions?: boolean; // default false (SQL v2.2+ enables; preset turns on)\n\ttwoSigmaIncludeAboveThree?: boolean; // default false (preset turns on)\n\t// Conflict handling: when both improvement and concern candidates\n\t// exist for a point (typically due to trend crossing the mean), prefer keeping\n\t// the improvement side regardless of PrimeDirection. Default false to retain\n\t// SQL v2.6a parity (PrimeDirection first, then MetricConflictRule only on ties).\n\t// NOTE: When this flag is true, the engine disables favourable trend segmentation\n\t// (both per-partition and across partitions). As a consequence, segmentation-dependent\n\t// controls like `preferTrendWhenConflict` and `trendDominatesHighlightedWindow` will have\n\t// no effect for those rows because no highlighted trend window is established.\n\tpreferImprovementWhenConflict?: boolean;\n\t// Configurable conflict resolution strategy; default keeps SQL parity.\n\tconflictStrategy?: ConflictStrategy;\n\t// When true, if both improvement and concern candidates exist on a row and one of the trend flags\n\t// (trendUp/trendDown) is present after segmentation, prefer the trend side and prune the other.\n\t// This helps datasets where a trend segment should dominate over non-trend rules within its window.\n\tpreferTrendWhenConflict?: boolean;\n\t// When using ConflictStrategy.RuleHierarchy, precedence order for rules from highest to lowest\n\t// Default mirrors SQL ranking: Trend > Shift > TwoSigma > SinglePoint\n\truleHierarchy?: SpcRuleId[];\n\t// When true, once the chart has at least `minimumPoints` non-ghosted values overall,\n\t// compute limits and evaluate rules across entire partitions (retrospective colouring of early rows).\n\t// When false (default), eligibility is per-point (prospective) using pointRank.\n\tchartLevelEligibility?: boolean;\n\t// When true (default), after trend flags are backfilled, split runs at mean crossings and\n\t// keep only favourable-side segments for contribution to classification, using a strategy.\n\t// This resolves Special-cause conflicts when a run crosses the mean by recoding the pre-crossing\n\t// segment to not participate in variation classification.\n\t// Deprecated: prefer trendSegmentationMode. If provided, `true` maps to `Always`, `false` maps to `Off`.\n\ttrendFavourableSegmentation?: boolean;\n\t// When and how to apply favourable trend segmentation. Default behaviour is `AutoWhenConflict` to\n\t// minimise impact on datasets without conflicts while resolving cross-mean trend conflicts when present.\n\ttrendSegmentationMode?: TrendSegmentationMode;\n\t// When true, within highlighted trend segments (post-segmentation), drop opposite-side non-trend\n\t// rule flags (singlePoint/twoSigma/shift) so the highlighted trend segment dominates classification\n\t// in its window. Default false to preserve SQL parity. Works independently of preferTrendWhenConflict\n\t// by manipulating rule flags earlier in the pipeline. Has no effect when\n\t// `preferImprovementWhenConflict` is true (segmentation disabled by engine gating).\n\ttrendDominatesHighlightedWindow?: boolean;\n\t// Strategy for picking which favourable-side segment(s) to keep when a run crosses the mean.\n\t// Default: TrendSegmentationStrategy.CrossingAfterFavourable \u2014 first favourable segment after crossing, else longest favourable.\n\ttrendSegmentationStrategy?: TrendSegmentationStrategy;\n}\n\n// The fully computed row emitted by the engine\nexport interface SpcRowV2 {\n\trowId: number;\n\tx: string | number | Date;\n\tvalue: number | null;\n\tghost: boolean;\n\tpartitionId: number;\n\tpointRank: number;\n\tmean: number | null;\n\tupperProcessLimit: number | null;\n\tlowerProcessLimit: number | null;\n\tupperTwoSigma: number | null;\n\tlowerTwoSigma: number | null;\n\tupperOneSigma: number | null;\n\tlowerOneSigma: number | null;\n\t// Rule flags (directional)\n\tsinglePointUp: boolean;\n\tsinglePointDown: boolean;\n\ttwoSigmaUp: boolean;\n\ttwoSigmaDown: boolean;\n\tshiftUp: boolean;\n\tshiftDown: boolean;\n\ttrendUp: boolean;\n\ttrendDown: boolean;\n\t// Candidate values (post-pruning optional)\n\tspecialCauseImprovementValue: number | null;\n\tspecialCauseConcernValue: number | null;\n\t// Summary (per-row for testing convenience)\n\tvariationIcon: VariationIcon;\n\t// Diagnostics\n\tprimeDirection?: PrimeDirection;\n\tprimeRank?: number;\n\tprimeRuleId?: SpcRuleId;\n}\n\n// The arguments to build an SPC result\nexport interface BuildArgsV2 {\n\tchartType: ChartType;\n\tmetricImprovement: ImprovementDirection;\n\tdata: SpcInputRowV2[];\n\tsettings?: SpcSettingsV26a;\n}\n\n// The build result containing all rows (warnings kept separate for clarity in this module)\nexport interface SpcResultV2 {\n\trows: SpcRowV2[];\n}\n", "import { SpcRuleId } from \"./types\";\n\n// Higher number = higher precedence (stronger rule).\n// Align exactly with SQL v2.6a conflict ranking used to compute PrimeDirection:\n// Trend (4) > Shift (3) > TwoSigma (2) > SinglePoint (1)\nexport const RULE_RANK_BY_ID: Record<SpcRuleId, number> = {\n\t[SpcRuleId.SinglePoint]: 1,\n\t[SpcRuleId.TwoSigma]: 2,\n\t[SpcRuleId.Shift]: 3,\n\t[SpcRuleId.Trend]: 4,\n};\n\n// XmR constants to mirror standard SPC formulas (SQL v2.6a parity)\n// d2 for n=2\nexport const D2 = 1.128 as const;\n// Moving range UCL factor\nexport const MR_UCL_FACTOR = 3.267 as const;\n// 3\u03C3 factor for XmR limits: mean \u00B1 2.66 * MRbar\nexport const XMR_THREE_SIGMA_FACTOR = 2.66 as const;\n", "// A small helper to check a value is a proper finite number.\nimport { MR_UCL_FACTOR, XMR_THREE_SIGMA_FACTOR } from \"./constants\";\n\nexport function isNumber(n: unknown): n is number {\n\treturn typeof n === \"number\" && !Number.isNaN(n);\n}\n\n// Arithmetic mean of a numeric array. Returns 0 when empty to avoid NaN.\nexport function mean(nums: number[]): number {\n\treturn nums.reduce((a, b) => a + b, 0) / (nums.length || 1);\n}\n\n// Compute moving ranges against the previous non-ghosted numeric value, returning null when not applicable.\nexport function movingRanges(\n\tvalues: (number | null | undefined)[],\n\tghosts: boolean[]\n): (number | null)[] {\n\tconst mr: (number | null)[] = new Array(values.length).fill(null);\n\tlet lastIdx: number | null = null;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tconst v = values[i];\n\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\tif (lastIdx !== null) {\n\t\t\tconst prev = values[lastIdx];\n\t\t\tif (isNumber(prev)) mr[i] = Math.abs(v - prev);\n\t\t}\n\t\tlastIdx = i;\n\t}\n\treturn mr;\n}\n\n// Compute MR mean with an optional single-pass exclusion of values above the UCL (3.267 * MRbar),\n// mirroring the SQL behaviour when moving range outlier removal is enabled.\nexport function mrMeanWithOptionalExclusion(\n\tmr: (number | null)[],\n\texcludeOutliers: boolean\n): { mrMean: number; mrUcl: number } {\n\tconst vals = mr.filter(isNumber) as number[];\n\tif (!vals.length) return { mrMean: NaN, mrUcl: NaN };\n\tlet arr = vals.slice();\n\tif (excludeOutliers) {\n\t\tconst meanMr = mean(arr);\n\t\tconst ucl = MR_UCL_FACTOR * meanMr; // standard MR UCL\n\t\tarr = arr.filter((v) => v <= ucl);\n\t}\n\tconst mrMean = mean(arr);\n\treturn { mrMean, mrUcl: MR_UCL_FACTOR * mrMean };\n}\n\n// Given a centre line and MR mean, return standard XmR limits and 1\u03C3/2\u03C3 bands.\nexport function xmrLimits(center: number, mrMean: number) {\n\t// When mrMean is 0 (flat series), produce zero-width limits at the center line\n\t// instead of nulls so partitions with no variation still render control lines.\n\tif (!isNumber(center) || !isNumber(mrMean)) {\n\t\treturn {\n\t\t\tupperProcessLimit: null,\n\t\t\tlowerProcessLimit: null,\n\t\t\tupperTwoSigma: null,\n\t\t\tlowerTwoSigma: null,\n\t\t\tupperOneSigma: null,\n\t\t\tlowerOneSigma: null,\n\t\t};\n\t}\n\tconst threeSigma = XMR_THREE_SIGMA_FACTOR * mrMean;\n\tconst twoSigma = (2 / 3) * threeSigma;\n\tconst oneSigma = (1 / 3) * threeSigma;\n\treturn {\n\t\tupperProcessLimit: center + threeSigma,\n\t\tlowerProcessLimit: center - threeSigma,\n\t\tupperTwoSigma: center + twoSigma,\n\t\tlowerTwoSigma: center - twoSigma,\n\t\tupperOneSigma: center + oneSigma,\n\t\tlowerOneSigma: center - oneSigma,\n\t};\n}\n", "import {\n\tisNumber,\n\tmean,\n\tmovingRanges,\n\tmrMeanWithOptionalExclusion,\n\txmrLimits,\n} from \"./utils\";\nimport { ChartType } from \"./types\";\n\n// Compute control lines for a single partition based on chart type.\n// For v2.6a parity we focus on XmR here; T and G can be added later.\nexport function computePartitionLimits(\n\tchartType: ChartType,\n\tvalues: (number | null)[],\n\tghosts: boolean[],\n\texcludeMovingRangeOutliers: boolean\n) {\n\tif (chartType !== ChartType.XmR) {\n\t\t// For v2.6a focus, we only implement XmR path now; T/G can be added later if needed\n\t\treturn {\n\t\t\tmean: NaN,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: null as number | null,\n\t\t\tlowerProcessLimit: null as number | null,\n\t\t\tupperTwoSigma: null as number | null,\n\t\t\tlowerTwoSigma: null as number | null,\n\t\t\tupperOneSigma: null as number | null,\n\t\t\tlowerOneSigma: null as number | null,\n\t\t};\n\t}\n\n\tconst mr = movingRanges(values, ghosts);\n\t// Raw MR mean/UCL used for determining which value points are excluded from the centre-line\n\tconst mrVals = mr.filter(isNumber) as number[];\n\tconst rawMrMean = mrVals.length ? mean(mrVals) : NaN;\n\tconst rawMrUcl = isNumber(rawMrMean) ? 3.267 * rawMrMean : NaN;\n\n\t// Compute centre line: optionally exclude values whose MR exceeds the RAW MR UCL (include first valued point where MR is null)\n\tlet center: number = NaN;\n\t{\n\t\tconst eligibleVals: number[] = [];\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst v = values[i];\n\t\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\t\tif (!excludeMovingRangeOutliers) {\n\t\t\t\teligibleVals.push(v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst mri = mr[i];\n\t\t\t// Include when MR is null (first point) or MR <= raw UCL\n\t\t\tif (mri === null || !isNumber(rawMrUcl) || (isNumber(mri) && mri <= rawMrUcl)) {\n\t\t\t\teligibleVals.push(v);\n\t\t\t}\n\t\t}\n\t\tcenter = eligibleVals.length ? mean(eligibleVals) : NaN;\n\t}\n\n\t// MR mean used for limits may itself exclude MR outliers (trim then recompute MRbar and UCL)\n\tconst tmp = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\tconst lim = xmrLimits(center, tmp.mrMean);\n\treturn {\n\t\tmean: center,\n\t\tmr,\n\t\tmrMean: tmp.mrMean,\n\t\tmrUcl: tmp.mrUcl,\n\t\t...lim,\n\t};\n}\n", "import { SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface DetectorConfig {\n\tshiftPoints: number;\n\ttrendPoints: number;\n\ttwoSigmaIncludeAboveThree?: boolean;\n}\n\nexport function detectRulesInPartition(rows: SpcRowV2[], cfg: DetectorConfig) {\n\tconst idxs = rows\n\t\t.map((_, i) => i)\n\t\t.filter((i) => !rows[i].ghost && isNumber(rows[i].value));\n\tconst get = (i: number) => rows[i];\n\tconst shiftN = cfg.shiftPoints;\n\tconst trendN = cfg.trendPoints;\n\n\t// Shift\n\tlet runHigh: number[] = [];\n\tlet runLow: number[] = [];\n\tfor (const i of idxs) {\n\t\tconst r = get(i);\n\t\tif (!isNumber(r.mean) || !isNumber(r.value)) {\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t\tcontinue;\n\t\t}\n\t\tif (r.value > r.mean) {\n\t\t\trunHigh.push(i);\n\t\t\trunLow = [];\n\t\t} else if (r.value < r.mean) {\n\t\t\trunLow.push(i);\n\t\t\trunHigh = [];\n\t\t} else {\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t}\n\t\tif (runHigh.length >= shiftN)\n\t\t\tfor (const j of runHigh) get(j).shiftUp = true;\n\t\tif (runLow.length >= shiftN)\n\t\t\tfor (const j of runLow) get(j).shiftDown = true;\n\t}\n\n\t// Two-of-three beyond 2\u03C3 (side-consistent)\n\tfor (let w = 0; w <= idxs.length - 3; w++) {\n\t\tconst win = idxs.slice(w, w + 3);\n\t\tconst trip = win.map(get);\n\t\tif (!trip.every((r) => isNumber(r.value) && isNumber(r.mean))) continue;\n\t\tconst mean = trip[0].mean!;\n\t\tconst allHigh = trip.every((r) => r.value! > mean);\n\t\tconst allLow = trip.every((r) => r.value! < mean);\n\t\tif (!allHigh && !allLow) continue;\n\t\tconst u2 = trip[0].upperTwoSigma ?? Infinity;\n\t\tconst l2 = trip[0].lowerTwoSigma ?? -Infinity;\n\t\tconst u3 = trip[0].upperProcessLimit ?? Infinity;\n\t\tconst l3 = trip[0].lowerProcessLimit ?? -Infinity;\n\t\tconst highs = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! > u2 : (r.value! > u2 && r.value! <= u3));\n\t\tconst lows = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! < l2 : (r.value! < l2 && r.value! >= l3));\n\t\tif (allHigh && highs.length >= 2)\n\t\t\thighs.forEach((r) => (r.twoSigmaUp = true));\n\t\tif (allLow && lows.length >= 2)\n\t\t\tlows.forEach((r) => (r.twoSigmaDown = true));\n\t}\n\n\t// Trend (strict monotonic inc/dec)\n\tfor (let w = 0; w <= idxs.length - trendN; w++) {\n\t\tconst win = idxs.slice(w, w + trendN);\n\t\tconst seq = win.map(get);\n\t\tif (!seq.every((r) => isNumber(r.value))) continue;\n\t\tlet inc = true;\n\t\tlet dec = true;\n\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\tif (!inc && !dec) break;\n\t\t}\n\t\tif (inc) win.forEach((i) => (get(i).trendUp = true));\n\t\tif (dec) win.forEach((i) => (get(i).trendDown = true));\n\t}\n}\n", "import {\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tPrimeDirection,\n\tSide,\n\tSpcRowV2,\n\tSpcRuleId,\n\tVariationIcon,\n} from \"./types\";\nimport { RULE_RANK_BY_ID } from \"./constants\";\n\n// Build per-side lists of active rules with numeric rank and compute the prime direction\n// by comparing the maximum rank on each side (Up vs Down), mirroring SQL's #ConflictRankingSummary.\nexport function getDirectionalSummary(row: SpcRowV2) {\n\tconst up: { id: SpcRuleId; rank: number }[] = [];\n\tconst dn: { id: SpcRuleId; rank: number }[] = [];\n\n\t// Single point and Two Sigma (separate one-sided flags)\n\tif (row.singlePointUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.singlePointDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.twoSigmaUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\tif (row.twoSigmaDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\t\n\t// Shift and Trend (no separate one-sided flags)\n\tif (row.shiftUp)\n\t\tup.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.shiftDown)\n\t\tdn.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.trendUp)\n\t\tup.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\tif (row.trendDown)\n\t\tdn.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\n\t// Determine prime direction by comparing max rank on each side\n\tconst upMax = up.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst dnMax = dn.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst primeDirection =\n\t\tupMax > dnMax\n\t\t\t? PrimeDirection.Upwards\n\t\t\t: dnMax > upMax\n\t\t\t\t? PrimeDirection.Downwards\n\t\t\t\t: PrimeDirection.Same;\n\treturn { up, dn, upMax, dnMax, primeDirection };\n}\n\n// Decide whether aligned (improvement side) and opposite (concern side) candidates exist,\n// prior to any pruning. Mirrors SQL formation of SpecialCauseImprovementValue/ConcernValue.\nexport function deriveOriginalCandidates(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection\n) {\n\t// Aligned = high side for Up metrics; low side for Down metrics\n\tconst aligned =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointDown ||\n\t\t\t\t\trow.twoSigmaDown ||\n\t\t\t\t\trow.shiftDown ||\n\t\t\t\t\trow.trendDown\n\t\t\t\t: false;\n\t\n\t// Opposite = low side for Up metrics; high side for Down metrics\n\tconst opposite =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointDown ||\n\t\t\t\trow.twoSigmaDown ||\n\t\t\t\trow.shiftDown ||\n\t\t\t\trow.trendDown\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t\t: false;\n\t\n\treturn { aligned, opposite };\n}\n\n// Apply SQL-like pruning rules when both candidates exist, using primeDirection and metricConflictRule\n// to remove one side. Also sets variationIcon to match the remaining candidate(s) and records diagnostics.\n// Notes on global gating and precedence (see engine.ts):\n// - When settings.preferImprovementWhenConflict is true the engine disables favourable trend segmentation\n//   before conflict resolution. That gating happens in engine.ts and ensures improvement-first behaviour\n//   cannot be counteracted by segmentation creating opposite-side trend candidates.\n// - Within pruning, preferTrendWhenConflict is an optional early tie-break that, when enabled, keeps the\n//   side that contains a trend flag and drops the opposite side. It runs only when both candidates exist.\nexport function applySqlPruning(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection,\n\tmetricConflictRule: MetricConflictRule,\n\tpreferImprovementWhenConflict = false,\n\tconflictStrategy?: ConflictStrategy,\n\truleHierarchy?: SpcRuleId[],\n\tpreferTrendWhenConflict = false\n) {\n\t// Get directional summary (also sets row.primeDirection)\n\tconst { up, dn, upMax, dnMax, primeDirection } = getDirectionalSummary(row);\n\trow.primeDirection = primeDirection;\n\tconst originalImprovement = row.specialCauseImprovementValue;\n\tconst originalConcern = row.specialCauseConcernValue;\n\n\t// If both candidates exist, prune one side based on strategy\n\tif (\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tresolveConflict({ row, metric, metricConflictRule, preferImprovementWhenConflict, preferTrendWhenConflict, primeDirection, conflictStrategy, ruleHierarchy });\n\t}\n\n\t// Update variation icon to reflect pruned candidates\n\tif (metric === ImprovementDirection.Up) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernLow\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\n\t// Down metrics\n\t} else if (metric === ImprovementDirection.Down) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementLow\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernHigh\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\t\n\t// Neither metrics\n\t} else {\n\t\t// Neither not used in SQL conflict pruning branch\n\t\trow.variationIcon = VariationIcon.CommonCause;\n\t}\n\n\t// prime rank and winner rule id\n\tconst winningSide =\n\t\trow.specialCauseImprovementValue !== null\n\t\t\t? Side.Up\n\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t? Side.Down\n\t\t\t\t: undefined;\n\tconst winningRank =\n\t\twinningSide === Side.Up\n\t\t\t? upMax\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dnMax\n\t\t\t\t: Math.max(upMax, dnMax);\n\trow.primeRank = winningRank || undefined;\n\tconst winner =\n\t\twinningSide === Side.Up\n\t\t\t? up.find((r) => r.rank === winningRank)\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dn.find((r) => r.rank === winningRank)\n\t\t\t\t: undefined;\n\trow.primeRuleId = winner?.id;\n\n\treturn { originalImprovement, originalConcern };\n}\n\n// General-purpose conflict resolver retaining SQL defaults but enabling alternative strategies.\n// When conflictStrategy is not supplied via settings, we infer it from preferImprovementWhenConflict flag\n// to preserve existing behaviour.\nexport function resolveConflict(args: {\n\trow: SpcRowV2;\n\tmetric: ImprovementDirection;\n\tmetricConflictRule: MetricConflictRule;\n\tpreferImprovementWhenConflict?: boolean;\n\tpreferTrendWhenConflict?: boolean;\n\tprimeDirection?: PrimeDirection;\n\tconflictStrategy?: ConflictStrategy;\n\truleHierarchy?: SpcRuleId[];\n}) {\n\tconst {\n\t\trow,\n\t\tmetric,\n\t\tmetricConflictRule,\n\t\tpreferImprovementWhenConflict,\n\t\tpreferTrendWhenConflict,\n\t\tprimeDirection = row.primeDirection ?? PrimeDirection.Same,\n\t\tconflictStrategy,\n\t\truleHierarchy,\n\t} = args;\n\t// Optional early override: when both candidates exist and a trend flag is present,\n\t// prefer the trend side over non-trend when requested. This runs before other strategies\n\t// to emulate story-specific expectations where a selected trend segment dominates.\n\tif (\n\t\tpreferTrendWhenConflict &&\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tconst upTrend = !!row.trendUp;\n\t\tconst downTrend = !!row.trendDown;\n\t\tif (metric === ImprovementDirection.Up) {\n\t\t\tif (upTrend && !downTrend) {\n\t\t\t\t// Keep improvement (high-side trend), drop concern\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!upTrend && downTrend) {\n\t\t\t\t// Keep concern (low-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\tif (downTrend && !upTrend) {\n\t\t\t\t// Keep improvement (low-side trend), drop concern (high)\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!downTrend && upTrend) {\n\t\t\t\t// Keep concern (high-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Prefer the explicit flag over strategy to mirror the intended Excel-like override.\n\t// If callers want a different behaviour, they should omit the flag and supply a strategy.\n\tconst strategy = preferImprovementWhenConflict\n\t\t? ConflictStrategy.PreferImprovement\n\t\t: conflictStrategy ?? ConflictStrategy.SqlPrimeThenRule;\n\n\tif (strategy === ConflictStrategy.PreferImprovement) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null;\n\t\telse if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t\treturn;\n\t}\n\n\tif (strategy === ConflictStrategy.RuleHierarchy) {\n\t\t// Determine which side contains the highest-precedence rule given an order (defaults to SQL rank)\n\t\tconst order: SpcRuleId[] = ruleHierarchy ?? [SpcRuleId.Trend, SpcRuleId.Shift, SpcRuleId.TwoSigma, SpcRuleId.SinglePoint];\n\t\tconst { up, dn } = getDirectionalSummary(row);\n\t\t// Find first rule in order that appears on either side\n\t\tfor (const rid of order) {\n\t\t\tconst upHas = up.some((r) => r.id === rid);\n\t\t\tconst dnHas = dn.some((r) => r.id === rid);\n\t\t\tif (upHas && !dnHas) {\n\t\t\t\t// keep Up side for Up metrics (improvement) else prune accordingly\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dnHas && !upHas) {\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else row.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upHas && dnHas) {\n\t\t\t\t// Both sides contain same highest rule: fall back to MetricConflictRule\n\t\t\t\tif (metric === ImprovementDirection.Up) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// If nothing matched, default to SQL behaviour\n\t}\n\n\t// Default (SQL parity): PrimeDirection first, then MetricConflictRule only when Same\n\tif (primeDirection === PrimeDirection.Upwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t} else if (primeDirection === PrimeDirection.Downwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseConcernValue = null;\n\t} else {\n\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t}\n}\n\n// Convenience helpers for diagnostics and potential UI integration\n// Compute whether any upward or downward side rules are present on a row\nexport function computeSideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n\tconst upAny = !!(row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp);\n\tconst downAny = !!(row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown);\n\treturn { upAny, downAny };\n}\n\n// True when both sides have at least one active rule (pre- or post-pruning agnostic)\nexport function hasDirectionalConflict(row: SpcRowV2): boolean {\n\tconst { upAny, downAny } = computeSideFlags(row);\n\treturn upAny && downAny;\n}\n", "import { AssuranceIcon, ChartType, ImprovementDirection, SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport function computeAssuranceIconXmR(\n\trow: SpcRowV2,\n\tmetricImprovement: ImprovementDirection,\n\ttarget: number | null | undefined\n): AssuranceIcon {\n\tif (\n\t\t!isNumber(target) ||\n\t\trow.mean === null ||\n\t\trow.upperProcessLimit === null ||\n\t\trow.lowerProcessLimit === null\n\t)\n\t\treturn AssuranceIcon.None;\n\tif (metricImprovement === ImprovementDirection.Up) {\n\t\tif (target <= row.lowerProcessLimit) return AssuranceIcon.Pass;\n\t\tif (target >= row.upperProcessLimit) return AssuranceIcon.Fail;\n\t\treturn AssuranceIcon.HitOrMiss;\n\t}\n\tif (metricImprovement === ImprovementDirection.Down) {\n\t\tif (target >= row.upperProcessLimit) return AssuranceIcon.Pass;\n\t\tif (target <= row.lowerProcessLimit) return AssuranceIcon.Fail;\n\t\treturn AssuranceIcon.HitOrMiss;\n\t}\n\treturn AssuranceIcon.None;\n}\n\n// Parity-facing helper: Suppress assurance for T/G and delegate to XmR logic otherwise\nexport function computeAssuranceIcon(\n\tchartType: ChartType,\n\trow: SpcRowV2,\n\tmetricImprovement: ImprovementDirection,\n\ttarget: number | null | undefined\n): AssuranceIcon {\n\tif (chartType !== ChartType.XmR) return AssuranceIcon.None;\n\treturn computeAssuranceIconXmR(row, metricImprovement, target);\n}\n", "import {\n\tImprovementDirection,\n\tSpcRowV2,\n\tTrendSegmentationStrategy,\n} from \"../types\";\n\nexport type TrendDirection = \"Up\" | \"Down\";\nexport type MeanSide = \"Above\" | \"Below\";\n\nexport interface TrendSegment {\n\ttrendDirection: TrendDirection;\n\tstart: number; // inclusive index in the provided rows array\n\tend: number; // inclusive index\n\tside: MeanSide; // side of mean for all rows in this segment\n\tminValue: number;\n\tmaxValue: number;\n\tmaxAbsDeltaFromMean: number; // max |value-mean| within segment\n}\n\nexport interface TrendRun {\n\ttrendDirection: TrendDirection;\n\tstart: number;\n\tend: number; // inclusive\n\tsegments: TrendSegment[];\n}\n\nfunction signOf(x: number): -1 | 0 | 1 {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n}\n\nfunction sideFor(delta: number): MeanSide | undefined {\n\tconst s = signOf(delta);\n\tif (s > 0) return \"Above\";\n\tif (s < 0) return \"Below\";\n\treturn undefined;\n}\n\n/**\n * Compute contiguous trend runs from backfilled trend flags, and split them into\n * mean-side-consistent segments (Above/Below) across partition mean steps.\n * Points equal to mean are treated as a boundary (not included in either side),\n * so segments will not include rows where value === mean.\n */\nexport function computeTrendSegments(\n\trows: ReadonlyArray<SpcRowV2>\n): TrendRun[] {\n\tconst runs: TrendRun[] = [];\n\n\t// Build contiguous runs for trendUp and trendDown separately\n\tlet i = 0;\n\twhile (i < rows.length) {\n\t\tconst r = rows[i];\n\t\tif (!r || r.value == null || r.ghost || (!r.trendUp && !r.trendDown)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst dir: TrendDirection = r.trendUp\n\t\t\t? \"Up\"\n\t\t\t: r.trendDown\n\t\t\t\t? \"Down\"\n\t\t\t\t: (undefined as any);\n\t\t// start of run\n\t\tlet start = i;\n\t\tlet j = i;\n\t\tfor (; j < rows.length; j++) {\n\t\t\tconst rr = rows[j];\n\t\t\tif (!rr || rr.value == null || rr.ghost) break;\n\t\t\tconst sameDir = dir === \"Up\" ? rr.trendUp : rr.trendDown;\n\t\t\tif (!sameDir) break;\n\t\t}\n\t\tconst end = j - 1; // inclusive\n\n\t\t// Segment this run into above/below-mean pieces\n\t\tconst segments: TrendSegment[] = [];\n\t\tlet segStart: number | undefined = undefined;\n\t\tlet segSide: MeanSide | undefined = undefined;\n\t\tlet minV = Infinity,\n\t\t\tmaxV = -Infinity,\n\t\t\tmaxAbsDelta = 0;\n\n\t\tfor (let k = start; k <= end; k++) {\n\t\t\tconst row = rows[k]!;\n\t\t\tif (row.value == null) continue;\n\t\t\tconst delta = row.value - (row.mean ?? 0);\n\t\t\tconst side = sideFor(delta);\n\n\t\t\tif (!side) {\n\t\t\t\t// value equals mean \u2192 boundary: close current seg (if any) and skip this row\n\t\t\t\tif (segStart !== undefined) {\n\t\t\t\t\tsegments.push({\n\t\t\t\t\t\ttrendDirection: dir,\n\t\t\t\t\t\tstart: segStart,\n\t\t\t\t\t\tend: k - 1,\n\t\t\t\t\t\tside: segSide!,\n\t\t\t\t\t\tminValue: minV,\n\t\t\t\t\t\tmaxValue: maxV,\n\t\t\t\t\t\tmaxAbsDeltaFromMean: maxAbsDelta,\n\t\t\t\t\t});\n\t\t\t\t\tsegStart = undefined;\n\t\t\t\t\tsegSide = undefined;\n\t\t\t\t\tminV = Infinity;\n\t\t\t\t\tmaxV = -Infinity;\n\t\t\t\t\tmaxAbsDelta = 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (segStart === undefined) {\n\t\t\t\t// start new segment\n\t\t\t\tsegStart = k;\n\t\t\t\tsegSide = side;\n\t\t\t\tminV = row.value;\n\t\t\t\tmaxV = row.value;\n\t\t\t\tmaxAbsDelta = Math.abs(delta);\n\t\t\t} else if (side !== segSide) {\n\t\t\t\t// flush previous segment and start new\n\t\t\t\tsegments.push({\n\t\t\t\t\ttrendDirection: dir,\n\t\t\t\t\tstart: segStart,\n\t\t\t\t\tend: k - 1,\n\t\t\t\t\tside: segSide!,\n\t\t\t\t\tminValue: minV,\n\t\t\t\t\tmaxValue: maxV,\n\t\t\t\t\tmaxAbsDeltaFromMean: maxAbsDelta,\n\t\t\t\t});\n\t\t\t\tsegStart = k;\n\t\t\t\tsegSide = side;\n\t\t\t\tminV = row.value;\n\t\t\t\tmaxV = row.value;\n\t\t\t\tmaxAbsDelta = Math.abs(delta);\n\t\t\t} else {\n\t\t\t\t// extend\n\t\t\t\tif (row.value < minV) minV = row.value;\n\t\t\t\tif (row.value > maxV) maxV = row.value;\n\t\t\t\tconst mad = Math.abs(delta);\n\t\t\t\tif (mad > maxAbsDelta) maxAbsDelta = mad;\n\t\t\t}\n\t\t}\n\t\tif (segStart !== undefined) {\n\t\t\tsegments.push({\n\t\t\t\ttrendDirection: dir,\n\t\t\t\tstart: segStart,\n\t\t\t\tend: end,\n\t\t\t\tside: segSide!,\n\t\t\t\tminValue: minV,\n\t\t\t\tmaxValue: maxV,\n\t\t\t\tmaxAbsDeltaFromMean: maxAbsDelta,\n\t\t\t});\n\t\t}\n\n\t\truns.push({ trendDirection: dir, start, end, segments });\n\t\ti = end + 1;\n\t}\n\n\treturn runs;\n}\n\nexport interface SegmentHighlightOptions {\n\tmetricImprovement: ImprovementDirection;\n\tstrategy?: TrendSegmentationStrategy;\n}\n\n/** Map metricImprovement to favourable mean side */\nfunction favourableSide(impr: ImprovementDirection): MeanSide | undefined {\n\tif (impr === ImprovementDirection.Up) return \"Above\";\n\tif (impr === ImprovementDirection.Down) return \"Below\";\n\treturn undefined;\n}\n\nfunction oppositeSide(side: MeanSide | undefined): MeanSide | undefined {\n  if (!side) return undefined;\n  return side === \"Above\" ? \"Below\" : \"Above\";\n}\n\n/**\n * Choose segments to highlight from a computed run set using a strategy.\n * - FavourableSide: highlight all segments on the favourable side of mean\n * - CrossingAfterFavourable: if a side change occurs, highlight only the first favourable-side\n *   segment after a crossing; otherwise fall back to FavourableSide\n * - ExtremeFavourable: pick the favourable-side segment with the largest |value-mean| extremum\n */\nexport function chooseSegmentsForHighlight(\n\truns: TrendRun[],\n\topts: SegmentHighlightOptions\n): TrendSegment[] {\n\n\tconst strategy = opts.strategy ?? TrendSegmentationStrategy.CrossingAfterFavourable;\n\tconst fav = favourableSide(opts.metricImprovement);\n\tconst unfav = oppositeSide(fav);\n\n\tconst highlight: TrendSegment[] = [];\n\n\tfor (const run of runs) {\n\t\tif (!fav) {\n\t\t\t// Neither: no inherent favourable side; choose the segment with largest absolute distance\n\t\t\tif (\n\t\t\t\tstrategy === TrendSegmentationStrategy.ExtremeFavourable ||\n\t\t\t\tstrategy === TrendSegmentationStrategy.CrossingAfterFavourable\n\t\t\t) {\n\t\t\t\tconst all = run.segments;\n\t\t\t\tif (all.length === 0) continue;\n\t\t\t\tlet best = all[0];\n\t\t\t\tfor (const s of all)\n\t\t\t\t\tif (s.maxAbsDeltaFromMean > best.maxAbsDeltaFromMean) best = s;\n\t\t\t\thighlight.push(best);\n\t\t\t} else {\n\t\t\t\t// FavourableSide in Neither -> nothing by default\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === fav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.UnfavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === unfav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterFavourable) {\n\t\t\t// Detect first segment with fav side that is preceded by a different side\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === fav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== fav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// if run starts already on favourable side and never crosses, fall back later\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\t// fall back: pick the longest favourable segment (by length) if any\n\t\t\t\tconst favSegs = segs.filter((s) => s.side === fav);\n\t\t\t\tif (favSegs.length > 0) {\n\t\t\t\t\tchosen = favSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tfavSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterUnfavourable) {\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === unfav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== unfav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\tconst unSegs = segs.filter((s) => s.side === unfav);\n\t\t\t\tif (unSegs.length > 0) {\n\t\t\t\t\tchosen = unSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tunSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstFavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === fav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstUnfavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === unfav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.end - b.start > a.end - a.start ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.end - b.start > a.end - a.start ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\thighlight.push(favSegs[favSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\thighlight.push(unSegs[unSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn highlight;\n}\n", "import { ImprovementDirection, SpcRowV2, VariationIcon } from \"../types\";\n\n// Engine-level visual categories (UI-agnostic). Keep separate from VariationIcon.\nexport enum SpcVisualCategory {\n  Common = \"Common\",\n  Improvement = \"Improvement\",\n  Concern = \"Concern\",\n  NoJudgement = \"NoJudgement\",\n}\n\nexport type TrendVisualMode = \"Ungated\" | \"Gated\";\n\nexport interface VisualCategoryOptions {\n  metricImprovement: ImprovementDirection;\n  trendVisualMode?: TrendVisualMode; // default Ungated\n  enableNeutralNoJudgement?: boolean; // default true\n}\n\n// Derive upAny/downAny flags from a row's directional rule flags\nfunction sideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n  const upAny = !!(row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp);\n  const downAny = !!(row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown);\n  return { upAny, downAny };\n}\n\n/**\n * Compute per-point visual categories from engine rows.\n *\n * Rules\n * - If both upAny and downAny \u2192 Improvement (prefer improvement in conflict)\n * - Else honour engine VariationIcon for improvement/concern\n * - Else when VariationIcon is a Neither* and any special-cause fired:\n *   - Ungated: colour directionally by metricImprovement and side\n *   - Otherwise: NoJudgement when enabled\n * - Else Common\n */\nexport function computeSpcVisualCategories(\n  rows: ReadonlyArray<SpcRowV2>,\n  opts: VisualCategoryOptions\n): SpcVisualCategory[] {\n  const metricImprovement = opts.metricImprovement;\n  const trendVisualMode: TrendVisualMode = opts.trendVisualMode ?? \"Ungated\";\n  const enableNeutral = opts.enableNeutralNoJudgement ?? true;\n  \n  return rows.map((row) => {\n    if (!row || row.value == null || row.ghost) return SpcVisualCategory.Common;\n    const { upAny, downAny } = sideFlags(row);\n\n    // Conflict tie-break: prefer Improvement\n    if (upAny && downAny) return SpcVisualCategory.Improvement;\n\n    // Honour engine variation categories first\n    switch (row.variationIcon) {\n      case VariationIcon.ImprovementHigh:\n      case VariationIcon.ImprovementLow:\n        return SpcVisualCategory.Improvement;\n      case VariationIcon.ConcernHigh:\n      case VariationIcon.ConcernLow:\n        return SpcVisualCategory.Concern;\n      case VariationIcon.NeitherHigh:\n      case VariationIcon.NeitherLow: {\n        // Neither metric: treat as neutral special-cause; allow ungated directional colour\n        if (\n          trendVisualMode === \"Ungated\" &&\n          metricImprovement !== ImprovementDirection.Neither\n        ) {\n          if (upAny && !downAny) {\n            return metricImprovement === ImprovementDirection.Up\n              ? SpcVisualCategory.Improvement\n              : SpcVisualCategory.Concern;\n          }\n          if (downAny && !upAny) {\n            return metricImprovement === ImprovementDirection.Down\n              ? SpcVisualCategory.Improvement\n              : SpcVisualCategory.Concern;\n          }\n        }\n        return enableNeutral ? SpcVisualCategory.NoJudgement : SpcVisualCategory.Common;\n      }\n      default:\n        return SpcVisualCategory.Common;\n    }\n  });\n}\n\nexport default { computeSpcVisualCategories, SpcVisualCategory };\n", "import { ImprovementDirection, SpcRowV2 } from \"../types\";\nimport {\n\tSpcVisualCategory,\n\tcomputeSpcVisualCategories,\n} from \"./visualCategories\";\n\nexport type BoundaryWindowsMode = \"Disabled\" | \"RecalcCrossing\";\n\nexport interface BoundaryWindowsOptions {\n\tmode?: BoundaryWindowsMode; // default: Disabled\n\tpreWindow?: number; // default: 2 (points immediately before boundary)\n\tpostWindow?: number; // default: 3 (points starting at boundary)\n\t/**\n\t * Controls the polarity of the pre-window category relative to the post-window.\n\t * - \"Opposite\" (default): pre-window uses the opposite category of post-window (contrast around boundary)\n\t * - \"Same\": pre-window uses the same category as post-window (uniform window around boundary)\n\t */\n\tprePolarity?: \"Opposite\" | \"Same\";\n\t/**\n\t * Optional explicit boundary indices to use instead of auto-detecting via partitionId changes.\n\t * Each index should correspond to the first point of a new partition (i.e., the baseline-marked row).\n\t */\n\tboundaryIndices?: number[];\n}\n\n/**\n * Compute visual categories with optional boundary-aware post-classification adjustments.\n *\n * Behaviour (RecalcCrossing):\n * - Detect each partition boundary (partitionId changes).\n * - Compute mean delta: first non-null mean in new partition minus last non-null mean in previous partition.\n * - Determine favourable direction based on metricImprovement (Up -> delta>0, Down -> delta<0).\n * - Apply small windows around the boundary:\n *   - postWindow points [boundary .. boundary+postWindow-1]: set to Improvement if favourable else Concern\n *   - preWindow points [boundary-preWindow .. boundary-1]: set to the opposite category\n * - Never override existing Improvement/Concern categories from base computation; only upgrade\n *   Common/NoJudgement into the window categories.\n * - If metricImprovement === Neither, or either side has no eligible mean, no adjustments are applied for that boundary.\n */\nexport function computeBoundaryWindowCategories(\n\trows: ReadonlyArray<SpcRowV2>,\n\tmetricImprovement: ImprovementDirection,\n\toptions?: BoundaryWindowsOptions\n): SpcVisualCategory[] {\n\tconst mode = options?.mode ?? \"Disabled\";\n\tif (!rows.length) return [];\n\t// Start from base visual categories\n\tlet out = computeSpcVisualCategories(rows, {\n\t\tmetricImprovement,\n\t\ttrendVisualMode: \"Ungated\",\n\t\tenableNeutralNoJudgement: true,\n\t});\n\n\tif (mode !== \"RecalcCrossing\") return out;\n\tif (metricImprovement === ImprovementDirection.Neither) return out;\n\n\tconst preWin = Math.max(0, options?.preWindow ?? 2);\n\tconst postWin = Math.max(0, options?.postWindow ?? 3);\n\tconst prePolarity = options?.prePolarity ?? \"Opposite\";\n\n\t// Helper: safely set category if current is Common/NoJudgement only\n\tconst setIfUpgrade = (idx: number, cat: SpcVisualCategory) => {\n\t\tif (idx < 0 || idx >= out.length) return;\n\t\tconst cur = out[idx];\n\t\tif (\n\t\t\tcur === SpcVisualCategory.Common ||\n\t\t\tcur === SpcVisualCategory.NoJudgement\n\t\t) {\n\t\t\tout[idx] = cat;\n\t\t}\n\t};\n\n\t// Fallback mean when eligibility-gated means are unavailable: average raw values in the partition\n\tconst partitionFallbackMean = (\n\t\tpid: number | string | null\n\t): number | null => {\n\t\tif (pid == null) return null;\n\t\tconst values: number[] = [];\n\t\tfor (const r of rows) {\n\t\t\tif (r.partitionId !== pid) continue;\n\t\t\tif (typeof r.value === \"number\" && !r.ghost) values.push(r.value);\n\t\t}\n\t\tif (!values.length) return null;\n\t\tconst sum = values.reduce((a, b) => a + b, 0);\n\t\treturn sum / values.length;\n\t};\n\n\t// Build list of boundary indices: prefer explicit list, otherwise detect by partitionId changes\n\tconst boundaries: number[] = Array.isArray(options?.boundaryIndices) && options!.boundaryIndices!.length\n\t\t? options!.boundaryIndices!.slice().filter((b) => Number.isFinite(b))\n\t\t: (() => {\n\t\t\tconst out: number[] = [];\n\t\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\t\tconst prev = rows[i - 1];\n\t\t\t\tconst cur = rows[i];\n\t\t\t\tif (!prev || !cur) continue;\n\t\t\t\tif (cur.partitionId === prev.partitionId) continue;\n\t\t\t\tout.push(i);\n\t\t\t}\n\t\t\treturn out;\n\t\t})();\n\n\tfor (const boundary of boundaries) {\n\t\tconst prev = rows[boundary - 1];\n\t\tconst cur = rows[boundary];\n\t\tif (!prev || !cur) continue;\n\n\t\t// Find last non-null mean in previous partition\n\t\tlet oldMean: number | null = null;\n\t\tfor (let j = boundary - 1; j >= 0; j--) {\n\t\t\tconst r = rows[j];\n\t\t\tif (r.partitionId !== prev.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\toldMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Find first non-null mean in new partition\n\t\tlet newMean: number | null = null;\n\t\tfor (let k = boundary; k < rows.length; k++) {\n\t\t\tconst r = rows[k];\n\t\t\tif (r.partitionId !== cur.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\tnewMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If eligibility prevented means from materialising on either side, fall back to raw partition averages\n\t\tif (oldMean == null)\n\t\t\toldMean = partitionFallbackMean(prev.partitionId ?? null);\n\t\tif (newMean == null)\n\t\t\tnewMean = partitionFallbackMean(cur.partitionId ?? null);\n\t\tif (oldMean == null || newMean == null) continue; // still insufficient info\n\t\tconst delta = newMean - oldMean;\n\t\tconst favourable =\n\t\t\tmetricImprovement === ImprovementDirection.Up ? delta > 0 : delta < 0;\n\t\tconst postCat = favourable\n\t\t\t? SpcVisualCategory.Improvement\n\t\t\t: SpcVisualCategory.Concern;\n\t\tconst preCat = prePolarity === \"Same\"\n\t\t\t? postCat\n\t\t\t: favourable\n\t\t\t\t? SpcVisualCategory.Concern\n\t\t\t\t: SpcVisualCategory.Improvement;\n\n\t\t// Apply pre-window\n\t\tfor (let p = 1; p <= preWin; p++) setIfUpgrade(boundary - p, preCat);\n\t\t// Apply post-window\n\t\tfor (let p = 0; p < postWin; p++) setIfUpgrade(boundary + p, postCat);\n\t}\n\n\treturn out;\n}\n\nexport default { computeBoundaryWindowCategories };\n", "import {\n\tBuildArgsV2,\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\tSpcResultV2,\n\tSpcRowV2,\n\tVariationIcon,\n} from \"./types\";\nimport { computePartitionLimits } from \"./limits\";\nimport { detectRulesInPartition } from \"./detector\";\nimport { applySqlPruning, deriveOriginalCandidates } from \"./conflict\";\nimport { computeTrendSegments, chooseSegmentsForHighlight } from \"./postprocess/trendSegments\";\nimport { computeSpcVisualCategories, SpcVisualCategory } from \"./postprocess/visualCategories\";\nimport { computeBoundaryWindowCategories, BoundaryWindowsOptions } from \"./postprocess/boundaryWindows\";\nimport { isNumber } from \"./utils\";\n\n// Build an SPC result aligned to SQL v2.6a, focusing on XmR.\n// Mirrors SQL steps but emits per-row icons; dataset parity compares the last non-ghosted row.\nexport function buildSpcV26a(args: BuildArgsV2): SpcResultV2 {\n\tconst { chartType, metricImprovement, data, settings } = args;\n\t// Consolidate settings with sensible defaults derived from SQL guidance\n\tconst s = {\n\t\tminimumPoints: 13,\n\t\tshiftPoints: 6,\n\t\ttrendPoints: 6,\n\t\texcludeMovingRangeOutliers: false,\n\t\tmetricConflictRule: MetricConflictRule.Improvement,\n\t\ttrendAcrossPartitions: false,\n\t\ttwoSigmaIncludeAboveThree: false,\n\t\tpreferImprovementWhenConflict: false,\n\t\tconflictStrategy: ConflictStrategy.SqlPrimeThenRule,\n\t\truleHierarchy: undefined,\n\t\tchartLevelEligibility: false,\n\t\ttrendFavourableSegmentation: false,\n\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\ttrendSegmentationStrategy: TrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...settings,\n\t};\n\n\t// Resolve legacy boolean to mode if provided explicitly in settings\n\tconst resolvedMode: TrendSegmentationMode =\n\t\targs.settings?.trendSegmentationMode ??\n\t\t(args.settings?.trendFavourableSegmentation === true\n\t\t\t? TrendSegmentationMode.Always\n\t\t\t: args.settings?.trendFavourableSegmentation === false\n\t\t\t? TrendSegmentationMode.Off\n\t\t\t: s.trendSegmentationMode!);\n\n\t// Canonical rows \u2014 ensure predictable structure and types used throughout the build\n\tconst canon = data.map((d, i) => ({\n\t\trowId: i + 1,\n\t\tx: d.x,\n\t\tvalue: isNumber(d.value) ? d.value! : null,\n\t\tghost: !!d.ghost,\n\t\tbaseline: !!d.baseline,\n\t\ttarget: isNumber(d.target) ? d.target! : null,\n\t}));\n\n\t// Partitioning \u2014 split series at baseline markers (inclusive), calculations occur within these partitions\n\tconst partitions: (typeof canon)[] = [];\n\tlet cur: typeof canon = [];\n\tfor (const r of canon) {\n\t\tif (r.baseline && cur.length) {\n\t\t\tpartitions.push(cur);\n\t\t\tcur = [];\n\t\t}\n\t\tcur.push(r);\n\t}\n\tif (cur.length) partitions.push(cur);\n\n\tconst out: SpcRowV2[] = [];\n\n\t// Global gating for trend segmentation: when preferImprovementWhenConflict is enabled,\n\t// we disable trend segmentation to better match datasets that expect improvement-side dominance\n\t// without segment masking side-effects around the mean crossings.\n\tconst segmentationEnabled =\n\t\t(s.trendFavourableSegmentation || resolvedMode !== TrendSegmentationMode.Off) &&\n\t\t!s.preferImprovementWhenConflict;\n\n\t// Determine chart-level eligibility when enabled: count all non-ghost, valued points across the chart\n\tconst totalEligiblePoints = canon.filter((r) => !r.ghost && isNumber(r.value)).length;\n\tconst chartEligible = !!s.chartLevelEligibility && totalEligiblePoints >= (s.minimumPoints!);\n\tlet partitionId = 0;\n\tfor (const part of partitions) {\n\t\tpartitionId++;\n\t\tconst values = part.map((p) => p.value);\n\t\tconst ghosts = part.map((p) => p.ghost);\n\n\t\t// Eligibility: gate control lines per-row within each partition based on pointRank\n\t\t// A row becomes eligible when there are at least `minimumPoints` non-ghost, valued points in its partition up to and including that row.\n\n\t\tconst lim = computePartitionLimits(\n\t\t\tchartType,\n\t\t\tvalues,\n\t\t\tghosts,\n\t\t\t!!s.excludeMovingRangeOutliers\n\t\t);\n\n\t\tconst withLines: SpcRowV2[] = part.map((r, i) => {\n\t\t\tconst pointRank =\n\t\t\t\t!r.ghost && isNumber(r.value)\n\t\t\t\t\t? values.slice(0, i + 1).filter((v, j) => !ghosts[j] && isNumber(v)).length\n\t\t\t\t\t: 0;\n\t\t\tconst eligibleHere = chartEligible ? true : pointRank >= (s.minimumPoints!);\n\t\t\treturn {\n\t\t\trowId: r.rowId,\n\t\t\tx: r.x,\n\t\t\tvalue: isNumber(r.value) ? r.value : null,\n\t\t\tghost: r.ghost,\n\t\t\tpartitionId,\n\t\t\tpointRank,\n\t\t\tmean: (eligibleHere || chartEligible) && isNumber(lim.mean) ? lim.mean : null,\n\t\t\tupperProcessLimit: (eligibleHere || chartEligible) ? lim.upperProcessLimit : null,\n\t\t\tlowerProcessLimit: (eligibleHere || chartEligible) ? lim.lowerProcessLimit : null,\n\t\t\tupperTwoSigma: (eligibleHere || chartEligible) ? lim.upperTwoSigma : null,\n\t\t\tlowerTwoSigma: (eligibleHere || chartEligible) ? lim.lowerTwoSigma : null,\n\t\t\tupperOneSigma: (eligibleHere || chartEligible) ? lim.upperOneSigma : null,\n\t\t\tlowerOneSigma: (eligibleHere || chartEligible) ? lim.lowerOneSigma : null,\n\t\t\t// rules\n\t\t\tsinglePointUp: false,\n\t\t\tsinglePointDown: false,\n\t\t\ttwoSigmaUp: false,\n\t\t\ttwoSigmaDown: false,\n\t\t\tshiftUp: false,\n\t\t\tshiftDown: false,\n\t\t\ttrendUp: false,\n\t\t\ttrendDown: false,\n\t\t\t// candidates\n\t\t\tspecialCauseImprovementValue: null,\n\t\t\tspecialCauseConcernValue: null,\n\t\t\tvariationIcon: VariationIcon.CommonCause,\n\t\t};\n\t\t});\n\n\t\t// Pass 1: single 3-sigma \u2014 mark any point beyond upper/lower process limits\n\t\tfor (const row of withLines) {\n\t\t\tif (\n\t\t\t\trow.ghost ||\n\t\t\t\t!isNumber(row.value) ||\n\t\t\t\trow.mean === null\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (\n\t\t\t\tisNumber(row.upperProcessLimit) &&\n\t\t\t\trow.value! > row.upperProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointUp = true;\n\t\t\tif (\n\t\t\t\tisNumber(row.lowerProcessLimit) &&\n\t\t\t\trow.value! < row.lowerProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointDown = true;\n\t\t}\n\n\t\t\t// Pass 2: patterns \u2014 shift, two-of-three, strict monotonic trend (per-partition)\n\t\t\tdetectRulesInPartition(withLines, {\n\t\t\t\tshiftPoints: s.shiftPoints!,\n\t\t\t\ttrendPoints: s.trendPoints!,\n\t\t\t\ttwoSigmaIncludeAboveThree: !!s.twoSigmaIncludeAboveThree,\n\t\t\t});\n\n\t\t// Optional post-detection step: trend favourable segmentation to resolve cross-mean conflicts\n\t\tconst maybeApplySegmentation = (rows: SpcRowV2[]) => {\n\t\t\t// Determine if this partition has any potential conflicts (both sides active on any row)\n\t\t\tconst hasConflict = rows.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Off ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && !hasConflict)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst runs = computeTrendSegments(rows);\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, {\n\t\t\t\tmetricImprovement,\n\t\t\t\tstrategy: s.trendSegmentationStrategy,\n\t\t\t});\n\t\t\t// Build directional allow masks so a row can only retain the trend flag\n\t\t\t// corresponding to the highlighted segment's direction it belongs to.\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === \"Up\") allowUp.add(k);\n\t\t\t\t\telse allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\trows.forEach((row, idx) => {\n\t\t\t\t// Recode trend flags to only keep those explicitly allowed by highlighted segments\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\t// Optional: let trend dominate inside highlighted window by clearing opposite-side non-trend flags\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\t// Inside an upward trend segment: drop down-side non-trend rules\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\t// Inside a downward trend segment: drop up-side non-trend rules\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tif (segmentationEnabled) {\n\t\t\tmaybeApplySegmentation(withLines);\n\t\t}\n\n\t\t// SQL candidate formation and pruning for all rows (engine v2.6a parity)\n\t\tfor (const row of withLines) {\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) {\n\t\t\t\tout.push(row);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(\n\t\t\t\trow,\n\t\t\t\tmetricImprovement\n\t\t\t);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\n\t\t\t\t\tif (metricImprovement === ImprovementDirection.Neither) {\n\t\t\t\t\t\t// Neither semantics: high-side rules -> NeitherHigh, low-side rules -> NeitherLow, else CommonCause\n\t\t\t\t\t\tconst highSide = row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp;\n\t\t\t\t\t\tconst lowSide = row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown;\n\t\t\t\t\t\trow.variationIcon = highSide ? VariationIcon.NeitherHigh : lowSide ? VariationIcon.NeitherLow : VariationIcon.CommonCause;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Up/Down metrics: apply SQL-style pruning and then set icon via pruning outcome\n\t\t\t\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t\t\t\t}\n\t\t\tout.push(row);\n\t\t}\n\t}\n\n\t// Optional global trend detection across partitions (SQL v2.2+):\n\tif (s.trendAcrossPartitions) {\n\t\t// Build a flat, ordered index of all non-ghost, valued rows\n\t\tconst all = out.map((r, i) => ({ idx: i, r })).filter(({ r }) => !r.ghost && isNumber(r.value));\n\t\tif (all.length >= s.trendPoints!) {\n\t\t\tfor (let w = 0; w <= all.length - s.trendPoints!; w++) {\n\t\t\t\tconst win = all.slice(w, w + s.trendPoints!).map((p) => p.idx);\n\t\t\t\tconst seq = win.map((i) => out[i]);\n\t\t\t\tif (!seq.every((row) => isNumber(row.value))) continue;\n\t\t\t\tlet inc = true;\n\t\t\t\tlet dec = true;\n\t\t\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\t\t\tif (!inc && !dec) break;\n\t\t\t\t}\n\t\t\t\tif (inc) win.forEach((i) => (out[i].trendUp = true));\n\t\t\t\tif (dec) win.forEach((i) => (out[i].trendDown = true));\n\t\t\t}\n\t\t}\n\t}\n\n\t// If global trend flags were added post hoc, re-apply pruning to stabilise variationIcon with updated rule flags\n\tif (s.trendAcrossPartitions) {\n\t\t// Optional: apply favourable trend segmentation across the whole series\n\t\tif (segmentationEnabled) {\n\t\t\tconst hasConflict = out.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Always ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && hasConflict)\n\t\t\t) {\n\t\t\tconst runs = computeTrendSegments(out);\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, { metricImprovement, strategy: s.trendSegmentationStrategy });\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === \"Up\") allowUp.add(k); else allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.forEach((row, idx) => {\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor (const row of out) {\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) continue;\n\t\t\tif (metricImprovement === ImprovementDirection.Neither) continue;\n\t\t\t// Recompute candidates from updated flags\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(row, metricImprovement);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t}\n\t}\n\n\treturn { rows: out };\n}\n\nexport default { buildSpcV26a };\n\n// Engine-owned visuals API: compute UI-agnostic visual categories with optional boundary-window upgrades\nexport function buildSpcV26aWithVisuals(\n\targs: BuildArgsV2,\n\tvisuals?: {\n\t\ttrendVisualMode?: \"Ungated\" | \"Gated\";\n\t\tenableNeutralNoJudgement?: boolean;\n\t\tboundaryWindows?: (BoundaryWindowsOptions & { directionOverride?: ImprovementDirection });\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst res = buildSpcV26a(args);\n\tconst base = computeSpcVisualCategories(res.rows, {\n\t\tmetricImprovement: args.metricImprovement,\n\t\ttrendVisualMode: visuals?.trendVisualMode ?? \"Ungated\",\n\t\tenableNeutralNoJudgement: visuals?.enableNeutralNoJudgement ?? true,\n\t});\n\n\tconst bw = visuals?.boundaryWindows;\n\tif (!bw || bw.mode !== \"RecalcCrossing\") return { rows: res.rows, visuals: base };\n\n\tconst dir = bw.directionOverride ?? args.metricImprovement;\n\tconst win = computeBoundaryWindowCategories(res.rows, dir, bw);\n\n\t// Overlay upgrade: only promote Common/NoJudgement to Improvement/Concern as per window categories\n\tconst overlay: SpcVisualCategory[] = base.map((cat, i) => {\n\t\tconst w = win[i];\n\t\tif (cat === SpcVisualCategory.Common || cat === SpcVisualCategory.NoJudgement) {\n\t\t\tif (w === SpcVisualCategory.Improvement) return SpcVisualCategory.Improvement;\n\t\t\tif (w === SpcVisualCategory.Concern) return SpcVisualCategory.Concern;\n\t\t}\n\t\treturn cat;\n\t});\n\treturn { rows: res.rows, visuals: overlay };\n}\n\nexport { SpcVisualCategory };\n", "import { buildSpcV26aWithVisuals, SpcVisualCategory } from \"./engine\";\nimport {\n\tBuildArgsV2,\n\tImprovementDirection,\n\tSpcRowV2,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\ttype SpcSettingsV26a,\n} from \"./types\";\n\nexport enum VisualsScenario {\n\tNone = \"none\",\n\tRecalcCrossingShift = \"recalc-crossing-shift\",\n\tRecalcCrossingTrend = \"recalc-crossing-trend\",\n\tRecalcCrossingTwoSigma = \"recalc-crossing-two-sigma\",\n\tRecalculationsRecalculated = \"recalculations-recalculated\",\n\tBaselinesRecalculated = \"baselines-recalculated\",\n}\n\nexport function buildVisualsForScenario(\n\targs: BuildArgsV2,\n\tscenario: VisualsScenario,\n\topts?: {\n\t\ttrendVisualMode?: \"Ungated\" | \"Gated\";\n\t\tenableNeutralNoJudgement?: boolean;\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst tvm = opts?.trendVisualMode ?? \"Ungated\";\n\tconst enn = opts?.enableNeutralNoJudgement ?? true;\n\n\t// Compute boundary indices from provided baselines first (deterministic in dataset tests)\n\tconst explicitBoundaries: number[] = Array.isArray(args.data)\n\t\t? args.data.map((d, i) => (d?.baseline ? i : -1)).filter((i) => i >= 0)\n\t\t: [];\n\n\tlet boundaryWindows: any | undefined;\n\tswitch (scenario) {\n\t\tcase VisualsScenario.RecalcCrossingShift: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 2,\n\t\t\t\tpostWindow: 4,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: ImprovementDirection.Down,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTrend: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 5,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: ImprovementDirection.Up,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTwoSigma: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 1,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: ImprovementDirection.Down,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.BaselinesRecalculated:\n\t\t\t// postWindow will be extended after build once we know boundary index and series length\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 0,\n\t\t\t\tpostWindow: 0,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: args.metricImprovement,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\tcase VisualsScenario.RecalculationsRecalculated:\n\t\tcase VisualsScenario.None:\n\t\tdefault:\n\t\t\tboundaryWindows = undefined;\n\t}\n\n\tconst { rows, visuals } = buildSpcV26aWithVisuals(args, {\n\t\ttrendVisualMode: tvm,\n\t\tenableNeutralNoJudgement: enn,\n\t\tboundaryWindows,\n\t});\n\n\tlet out = visuals.slice();\n\n\t// Find first boundary index (prefer explicit baselines)\n\tlet boundaryIndex = explicitBoundaries.length ? explicitBoundaries[0]! : -1;\n\tif (boundaryIndex < 0) {\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tif (rows[i].partitionId !== rows[i - 1].partitionId) {\n\t\t\t\tboundaryIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scenario-specific adjustments\n\tif (\n\t\tscenario === VisualsScenario.RecalculationsRecalculated ||\n\t\tscenario === VisualsScenario.BaselinesRecalculated\n\t) {\n\t\tif (boundaryIndex > 0) {\n\t\t\tout[boundaryIndex - 1] = SpcVisualCategory.Common;\n\t\t}\n\t}\n\t// For BaselinesRecalculated, we do not force post-baseline colours here; dataset expectations provide explicit colours.\n\n\treturn { rows, visuals: out };\n}\n\n// ---- Settings presets (engine-owned) ----\n\n// SQL v2.6 parity preset (with trend across partitions from SQL v2.2 note)\nexport const PARITY_V26: Readonly<SpcSettingsV26a> = Object.freeze({\n\tminimumPoints: 13,\n\tshiftPoints: 6,\n\ttrendPoints: 6,\n\texcludeMovingRangeOutliers: false,\n\tmetricConflictRule: MetricConflictRule.Improvement,\n\ttrendAcrossPartitions: true,\n\ttwoSigmaIncludeAboveThree: true,\n\tchartLevelEligibility: true,\n});\n\nexport function withParityV26(overrides?: SpcSettingsV26a): SpcSettingsV26a {\n\treturn { ...PARITY_V26, ...(overrides ?? {}) };\n}\n\n// Conflict-focused preset for datasets with trend/mean crossings.\n// Uses segmentation with CrossingAfterUnfavourable and keeps other parity defaults.\nexport function withConflictPresetV26(\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\treturn withParityV26({\n\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\ttrendSegmentationStrategy:\n\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t// Keep strict SQL pruning semantics by default; allow caller to opt into stronger levers below\n\t\tpreferTrendWhenConflict: false,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...(overrides ?? {}),\n\t});\n}\n\n// Direction-aware conflict preset that auto-chooses the safest behaviour per improvement direction:\n//  - Up (\"High is good\"): prefer improvement override and implicitly disable segmentation via engine gating\n//  - Down (\"Low is good\"): keep segmentation enabled with CrossingAfterUnfavourable (works for dataset parity)\n//  - Neither: fall back to generic conflict preset defaults\n// Overrides are applied last so callers (e.g. Storybook controls) can still force a specific behaviour.\nexport function withConflictPresetAutoV26(\n\tmetricImprovement: ImprovementDirection,\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\tswitch (metricImprovement) {\n\t\tcase ImprovementDirection.Up:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Engine will gate segmentation off when this is true\n\t\t\t\tpreferImprovementWhenConflict: true,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tcase ImprovementDirection.Down:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Keep segmentation to resolve cross-mean runs for low-is-good datasets\n\t\t\t\tpreferImprovementWhenConflict: false,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\t\t\ttrendSegmentationStrategy:\n\t\t\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tdefault:\n\t\t\treturn withConflictPresetV26({ ...(overrides ?? {}) });\n\t}\n}\n// Named exports only; no default export to avoid collisions\n", "// Optional preprocessing helpers to derive interval series for T and G charts.\n// These helpers are intentionally simple and make no statistical guarantees; they are\n// provided to shape raw event streams into interval/count sequences suitable for XmR-like\n// processing or for future T/G chart implementations.\n\nexport interface EventLike { x: string | number | Date }\n\n// Convert a sorted series of event times into time-between-events intervals.\n// If there are fewer than 2 events, returns an empty array.\nexport function toTimeBetweenEvents<T extends EventLike>(\n  events: T[],\n  opts?: { toMillis?: (x: T[\"x\"]) => number }\n) {\n  const toMs = opts?.toMillis ?? ((x: T[\"x\"]) => new Date(x as any).getTime());\n  const res: Array<{ x: T[\"x\"]; value: number } > = [];\n  if (events.length < 2) return res;\n  for (let i = 1; i < events.length; i++) {\n    const prev = toMs(events[i - 1].x);\n    const cur = toMs(events[i].x);\n    res.push({ x: events[i].x, value: Math.max(0, cur - prev) });\n  }\n  return res;\n}\n\n// Convert a stream of daily (or period) event markers into counts between events over a sliding window.\n// Simplest form: given booleans or numbers per day, emit the distance since the previous non-zero occurrence.\nexport function toCountBetweenEvents<T extends { x: string | number | Date; occurred?: boolean | number }>(\n  rows: T[]\n) {\n  const res: Array<{ x: T[\"x\"]; value: number } > = [];\n  let since = 0;\n  for (const r of rows) {\n    since += 1;\n    const hit = typeof r.occurred === 'number' ? r.occurred > 0 : !!r.occurred;\n    if (hit) {\n      res.push({ x: r.x, value: since });\n      since = 0;\n    }\n  }\n  return res;\n}\n", "import { ImprovementDirection, SpcRowV2, VariationIcon } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface RetroOverlayOptions {\n\t// Currently we only support retro-colouring for confirmed shift runs.\n\t// Two-of-three and single >3\u03C3 are intentionally not backfilled to keep\n\t// alignment with NHSE SQL semantics for per-row eligibility.\n\tenableShift?: boolean;\n}\n\nfunction iconFor(\n\tside: \"up\" | \"down\",\n\tdir: ImprovementDirection\n): VariationIcon {\n\tif (dir === ImprovementDirection.Neither) {\n\t\treturn side === \"up\" ? VariationIcon.NeitherHigh : VariationIcon.NeitherLow;\n\t}\n\tif (dir === ImprovementDirection.Up) {\n\t\treturn side === \"up\"\n\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t: VariationIcon.ConcernLow;\n\t}\n\t// dir === Down\n\treturn side === \"up\"\n\t\t? VariationIcon.ConcernHigh\n\t\t: VariationIcon.ImprovementLow;\n}\n\n/**\n * Compute a \"teaching view\" overlay that retro-colours pre-eligibility points\n * that sit on the same side of the mean as a later confirmed shift run.\n *\n * Notes and constraints (to preserve SQL parity):\n * - Engine rows remain unchanged; callers should only use these icons for\n *   visuals. The default engine `variationIcon` is still the source of truth\n *   for parity and testing.\n * - Only shift runs are backfilled; single-point and two-of-three are not\n *   retro-coloured.\n * - Backfill stops at the first eligible row in the partition; we never paint\n *   into rows where the engine would not have had limits yet.\n */\nexport function computeRetroShiftOverlay(\n\trows: SpcRowV2[],\n\tmetricImprovement: ImprovementDirection,\n\topts?: RetroOverlayOptions\n): Array<VariationIcon | null> {\n\tconst { enableShift = true } = opts ?? {};\n\tconst overlay: Array<VariationIcon | null> = Array(rows.length).fill(null);\n\tif (!enableShift) return overlay;\n\n\t// Group indices by partition\n\tconst byPart = new Map<number, number[]>();\n\trows.forEach((r, i) => {\n\t\tif (!byPart.has(r.partitionId)) byPart.set(r.partitionId, []);\n\t\tbyPart.get(r.partitionId)!.push(i);\n\t});\n\n\tfor (const [, idxs] of byPart) {\n\t\t// Identify the first eligible index in this partition\n\t\tconst firstEligibleIdx = idxs.find((i) => isNumber(rows[i].mean));\n\t\tif (firstEligibleIdx == null) continue;\n\n\t\t// Walk through eligible rows to find contiguous shift runs; for each run,\n\t\t// extend backwards across pre-eligibility rows that lie on the same side of\n\t\t// the mean at the run's start.\n\t\tlet runStart: number | null = null;\n\t\tlet runSide: \"up\" | \"down\" | null = null;\n\n\t\tconst commitRun = (startIdx: number, side: \"up\" | \"down\") => {\n\t\t\t// Use the mean at startIdx as the reference; walk backwards to just before\n\t\t\t// the first eligible index, colouring points that lie on the same side.\n\t\t\tconst refMean = rows[startIdx].mean!;\n\t\t\tfor (let j = startIdx - 1; j >= idxs[0]; j--) {\n\t\t\t\tconst r = rows[j];\n\t\t\t\tif (r.ghost || !isNumber(r.value)) continue;\n\t\t\t\tif (j >= firstEligibleIdx) break; // never paint into eligible region\n\t\t\t\tconst sameSide =\n\t\t\t\t\tside === \"up\" ? r.value! > refMean : r.value! < refMean;\n\t\t\t\tif (!sameSide) break; // stop when side breaks\n\t\t\t\toverlay[j] = iconFor(side, metricImprovement);\n\t\t\t}\n\t\t};\n\n\t\tfor (const i of idxs) {\n\t\t\tconst r = rows[i];\n\t\t\tconst eligible = isNumber(r.mean);\n\t\t\tif (!eligible) continue; // only scan shift runs where engine was eligible\n\n\t\t\tconst up = !!r.shiftUp;\n\t\t\tconst down = !!r.shiftDown;\n\t\t\tconst side: \"up\" | \"down\" | null = up ? \"up\" : down ? \"down\" : null;\n\n\t\t\tif (side) {\n\t\t\t\t// If we are starting or continuing a run, manage state\n\t\t\t\tif (runStart == null) {\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t} else if (runSide === side) {\n\t\t\t\t\t// continuing same-side run \u2014 nothing else to do yet\n\t\t\t\t} else {\n\t\t\t\t\t// side flipped \u2014 commit previous run and start new\n\t\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t}\n\t\t\t} else if (runStart != null) {\n\t\t\t\t// run ended; commit and reset\n\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\trunStart = null;\n\t\t\t\trunSide = null;\n\t\t\t}\n\t\t}\n\n\t\t// Commit trailing run if still open\n\t\tif (runStart != null && runSide != null) commitRun(runStart, runSide);\n\t}\n\n\treturn overlay;\n}\n\nexport default { computeRetroShiftOverlay };\n"],
  "mappings": "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",
  "names": ["ChartType", "ImprovementDirection", "VariationIcon", "AssuranceIcon", "SpcRuleId", "PrimeDirection", "Side", "MetricConflictRule", "ConflictStrategy", "TrendSegmentationStrategy", "TrendSegmentationMode", "mean", "SpcVisualCategory", "out", "VisualsScenario"]
}
