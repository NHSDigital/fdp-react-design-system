{
  "version": 3,
  "sources": ["../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/types.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/constants.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/utils.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/limits.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/detector.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/conflict.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/assurance.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/engine.ts", "../../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/presets.ts"],
  "sourcesContent": ["// Strongly-typed enums and core types mirroring SQL v2.6a naming.\n// These names are chosen to be easy to cross-reference with the SQL script and docs.\n\n// Supported chart types \u2014 v2.6a parity focuses on XmR; T and G can be added as needed\nexport enum ChartType {\n\tXmR = \"XmR\",\n\tT = \"T\",\n\tG = \"G\",\n}\n\n// How a metric is judged: higher is better, lower is better, or neither (neutral)\nexport enum ImprovementDirection {\n\tUp = \"Up\",\n\tDown = \"Down\",\n\tNeither = \"Neither\",\n}\n\n// Variation icon classification used for testing parity against SQL.\n// SQL v2.6a emits icons only for the last point, but we retain a per-row value for convenience.\nexport enum VariationIcon {\n\tImprovementHigh = \"ImprovementHigh\", // improvement on the high side (metric Up)\n\tImprovementLow = \"ImprovementLow\", // improvement on the low side (metric Down)\n\tConcernHigh = \"ConcernHigh\", // concern on the high side (metric Down)\n\tConcernLow = \"ConcernLow\", // concern on the low side (metric Up)\n\tNeitherHigh = \"NeitherHigh\", // neutral with a high-side special cause for Neither metrics\n\tNeitherLow = \"NeitherLow\", // neutral with a low-side special cause for Neither metrics\n\tCommonCause = \"CommonCause\", // no special cause detected contributing to icon\n}\n\n// Assurance outcome relative to target and process limits (XmR only in this module)\nexport enum AssuranceIcon {\n\tNone = \"None\",\n\tPass = \"Pass\",\n\tHitOrMiss = \"HitOrMiss\",\n\tFail = \"Fail\",\n}\n\n// Identifiers for rule types used in ranking and diagnostics\nexport enum SpcRuleId {\n\tSinglePoint = \"SinglePoint\",\n\tTwoSigma = \"TwoSigma\",\n\tShift = \"Shift\",\n\tTrend = \"Trend\",\n}\n\n// Direction determined by comparing the strongest rule rank on each side\nexport enum PrimeDirection {\n\tUpwards = \"Upwards\",\n\tDownwards = \"Downwards\",\n\tSame = \"Same\",\n}\n\n// Convenience to describe which side of the mean a signal sits on\nexport enum Side {\n\tUp = \"Up\",\n\tDown = \"Down\",\n}\n\n// Policy to apply when PrimeDirection is Same and both candidates exist\nexport enum MetricConflictRule {\n\tImprovement = \"Improvement\",\n\tConcern = \"Concern\",\n}\n\n// The input row shape accepted by the engine\nexport interface SpcInputRowV2 {\n\tx: string | number | Date;\n\tvalue?: number | null;\n\tghost?: boolean;\n\tbaseline?: boolean;\n\ttarget?: number | null;\n}\n\n// Settings that influence rule thresholds and pruning behaviour\nexport interface SpcSettingsV26a {\n\tminimumPoints?: number; // global gating\n\tshiftPoints?: number; // default 6\n\ttrendPoints?: number; // default 6\n\texcludeMovingRangeOutliers?: boolean; // default false\n\tmetricConflictRule?: MetricConflictRule; // default Improvement\n\t// Parity-specific controls\n\ttrendAcrossPartitions?: boolean; // default false (SQL v2.2+ enables; preset turns on)\n\ttwoSigmaIncludeAboveThree?: boolean; // default false (preset turns on)\n}\n\n// The fully computed row emitted by the engine\nexport interface SpcRowV2 {\n\trowId: number;\n\tx: string | number | Date;\n\tvalue: number | null;\n\tghost: boolean;\n\tpartitionId: number;\n\tpointRank: number;\n\tmean: number | null;\n\tupperProcessLimit: number | null;\n\tlowerProcessLimit: number | null;\n\tupperTwoSigma: number | null;\n\tlowerTwoSigma: number | null;\n\tupperOneSigma: number | null;\n\tlowerOneSigma: number | null;\n\t// Rule flags (directional)\n\tsinglePointUp: boolean;\n\tsinglePointDown: boolean;\n\ttwoSigmaUp: boolean;\n\ttwoSigmaDown: boolean;\n\tshiftUp: boolean;\n\tshiftDown: boolean;\n\ttrendUp: boolean;\n\ttrendDown: boolean;\n\t// Candidate values (post-pruning optional)\n\tspecialCauseImprovementValue: number | null;\n\tspecialCauseConcernValue: number | null;\n\t// Summary (per-row for testing convenience)\n\tvariationIcon: VariationIcon;\n\t// Diagnostics\n\tprimeDirection?: PrimeDirection;\n\tprimeRank?: number;\n\tprimeRuleId?: SpcRuleId;\n}\n\n// The arguments to build an SPC result\nexport interface BuildArgsV2 {\n\tchartType: ChartType;\n\tmetricImprovement: ImprovementDirection;\n\tdata: SpcInputRowV2[];\n\tsettings?: SpcSettingsV26a;\n}\n\n// The build result containing all rows (warnings kept separate for clarity in this module)\nexport interface SpcResultV2 {\n\trows: SpcRowV2[];\n}\n", "import { SpcRuleId } from \"./types\";\n\nexport const RULE_RANK_BY_ID: Record<SpcRuleId, number> = {\n\t[SpcRuleId.SinglePoint]: 1,\n\t[SpcRuleId.TwoSigma]: 2,\n\t[SpcRuleId.Shift]: 3,\n\t[SpcRuleId.Trend]: 4,\n};\n\n// XmR constants to mirror standard SPC formulas (SQL v2.6a parity)\n// d2 for n=2\nexport const D2 = 1.128 as const;\n// Moving range UCL factor\nexport const MR_UCL_FACTOR = 3.267 as const;\n// 3\u03C3 factor for XmR limits: mean \u00B1 2.66 * MRbar\nexport const XMR_THREE_SIGMA_FACTOR = 2.66 as const;\n", "// A small helper to check a value is a proper finite number.\nimport { MR_UCL_FACTOR, XMR_THREE_SIGMA_FACTOR } from \"./constants\";\n\nexport function isNumber(n: unknown): n is number {\n\treturn typeof n === \"number\" && !Number.isNaN(n);\n}\n\n// Arithmetic mean of a numeric array. Returns 0 when empty to avoid NaN.\nexport function mean(nums: number[]): number {\n\treturn nums.reduce((a, b) => a + b, 0) / (nums.length || 1);\n}\n\n// Compute moving ranges against the previous non-ghosted numeric value, returning null when not applicable.\nexport function movingRanges(\n\tvalues: (number | null | undefined)[],\n\tghosts: boolean[]\n): (number | null)[] {\n\tconst mr: (number | null)[] = new Array(values.length).fill(null);\n\tlet lastIdx: number | null = null;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tconst v = values[i];\n\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\tif (lastIdx !== null) {\n\t\t\tconst prev = values[lastIdx];\n\t\t\tif (isNumber(prev)) mr[i] = Math.abs(v - prev);\n\t\t}\n\t\tlastIdx = i;\n\t}\n\treturn mr;\n}\n\n// Compute MR mean with an optional single-pass exclusion of values above the UCL (3.267 * MRbar),\n// mirroring the SQL behaviour when moving range outlier removal is enabled.\nexport function mrMeanWithOptionalExclusion(\n\tmr: (number | null)[],\n\texcludeOutliers: boolean\n): { mrMean: number; mrUcl: number } {\n\tconst vals = mr.filter(isNumber) as number[];\n\tif (!vals.length) return { mrMean: NaN, mrUcl: NaN };\n\tlet arr = vals.slice();\n\tif (excludeOutliers) {\n\t\tconst meanMr = mean(arr);\n\t\tconst ucl = MR_UCL_FACTOR * meanMr; // standard MR UCL\n\t\tarr = arr.filter((v) => v <= ucl);\n\t}\n\tconst mrMean = mean(arr);\n\treturn { mrMean, mrUcl: MR_UCL_FACTOR * mrMean };\n}\n\n// Given a centre line and MR mean, return standard XmR limits and 1\u03C3/2\u03C3 bands.\nexport function xmrLimits(center: number, mrMean: number) {\n\t// When mrMean is 0 (flat series), produce zero-width limits at the center line\n\t// instead of nulls so partitions with no variation still render control lines.\n\tif (!isNumber(center) || !isNumber(mrMean)) {\n\t\treturn {\n\t\t\tupperProcessLimit: null,\n\t\t\tlowerProcessLimit: null,\n\t\t\tupperTwoSigma: null,\n\t\t\tlowerTwoSigma: null,\n\t\t\tupperOneSigma: null,\n\t\t\tlowerOneSigma: null,\n\t\t};\n\t}\n\tconst threeSigma = XMR_THREE_SIGMA_FACTOR * mrMean;\n\tconst twoSigma = (2 / 3) * threeSigma;\n\tconst oneSigma = (1 / 3) * threeSigma;\n\treturn {\n\t\tupperProcessLimit: center + threeSigma,\n\t\tlowerProcessLimit: center - threeSigma,\n\t\tupperTwoSigma: center + twoSigma,\n\t\tlowerTwoSigma: center - twoSigma,\n\t\tupperOneSigma: center + oneSigma,\n\t\tlowerOneSigma: center - oneSigma,\n\t};\n}\n", "import {\n\tisNumber,\n\tmean,\n\tmovingRanges,\n\tmrMeanWithOptionalExclusion,\n\txmrLimits,\n} from \"./utils\";\nimport { ChartType } from \"./types\";\n\n// Compute control lines for a single partition based on chart type.\n// For v2.6a parity we focus on XmR here; T and G can be added later.\nexport function computePartitionLimits(\n\tchartType: ChartType,\n\tvalues: (number | null)[],\n\tghosts: boolean[],\n\texcludeMovingRangeOutliers: boolean\n) {\n\tif (chartType !== ChartType.XmR) {\n\t\t// For v2.6a focus, we only implement XmR path now; T/G can be added later if needed\n\t\treturn {\n\t\t\tmean: NaN,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: null as number | null,\n\t\t\tlowerProcessLimit: null as number | null,\n\t\t\tupperTwoSigma: null as number | null,\n\t\t\tlowerTwoSigma: null as number | null,\n\t\t\tupperOneSigma: null as number | null,\n\t\t\tlowerOneSigma: null as number | null,\n\t\t};\n\t}\n\n\tconst mr = movingRanges(values, ghosts);\n\t// Raw MR mean/UCL used for determining which value points are excluded from the centre-line\n\tconst mrVals = mr.filter(isNumber) as number[];\n\tconst rawMrMean = mrVals.length ? mean(mrVals) : NaN;\n\tconst rawMrUcl = isNumber(rawMrMean) ? 3.267 * rawMrMean : NaN;\n\n\t// Compute centre line: optionally exclude values whose MR exceeds the RAW MR UCL (include first valued point where MR is null)\n\tlet center: number = NaN;\n\t{\n\t\tconst eligibleVals: number[] = [];\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tconst v = values[i];\n\t\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\t\tif (!excludeMovingRangeOutliers) {\n\t\t\t\teligibleVals.push(v);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst mri = mr[i];\n\t\t\t// Include when MR is null (first point) or MR <= raw UCL\n\t\t\tif (mri === null || !isNumber(rawMrUcl) || (isNumber(mri) && mri <= rawMrUcl)) {\n\t\t\t\teligibleVals.push(v);\n\t\t\t}\n\t\t}\n\t\tcenter = eligibleVals.length ? mean(eligibleVals) : NaN;\n\t}\n\n\t// MR mean used for limits may itself exclude MR outliers (trim then recompute MRbar and UCL)\n\tconst tmp = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\tconst lim = xmrLimits(center, tmp.mrMean);\n\treturn {\n\t\tmean: center,\n\t\tmr,\n\t\tmrMean: tmp.mrMean,\n\t\tmrUcl: tmp.mrUcl,\n\t\t...lim,\n\t};\n}\n", "import { SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface DetectorConfig {\n\tshiftPoints: number;\n\ttrendPoints: number;\n\ttwoSigmaIncludeAboveThree?: boolean;\n}\n\nexport function detectRulesInPartition(rows: SpcRowV2[], cfg: DetectorConfig) {\n\tconst idxs = rows\n\t\t.map((_, i) => i)\n\t\t.filter((i) => !rows[i].ghost && isNumber(rows[i].value));\n\tconst get = (i: number) => rows[i];\n\tconst shiftN = cfg.shiftPoints;\n\tconst trendN = cfg.trendPoints;\n\n\t// Shift\n\tlet runHigh: number[] = [];\n\tlet runLow: number[] = [];\n\tfor (const i of idxs) {\n\t\tconst r = get(i);\n\t\tif (!isNumber(r.mean) || !isNumber(r.value)) {\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t\tcontinue;\n\t\t}\n\t\tif (r.value > r.mean) {\n\t\t\trunHigh.push(i);\n\t\t\trunLow = [];\n\t\t} else if (r.value < r.mean) {\n\t\t\trunLow.push(i);\n\t\t\trunHigh = [];\n\t\t} else {\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t}\n\t\tif (runHigh.length >= shiftN)\n\t\t\tfor (const j of runHigh) get(j).shiftUp = true;\n\t\tif (runLow.length >= shiftN)\n\t\t\tfor (const j of runLow) get(j).shiftDown = true;\n\t}\n\n\t// Two-of-three beyond 2\u03C3 (side-consistent)\n\tfor (let w = 0; w <= idxs.length - 3; w++) {\n\t\tconst win = idxs.slice(w, w + 3);\n\t\tconst trip = win.map(get);\n\t\tif (!trip.every((r) => isNumber(r.value) && isNumber(r.mean))) continue;\n\t\tconst mean = trip[0].mean!;\n\t\tconst allHigh = trip.every((r) => r.value! > mean);\n\t\tconst allLow = trip.every((r) => r.value! < mean);\n\t\tif (!allHigh && !allLow) continue;\n\t\tconst u2 = trip[0].upperTwoSigma ?? Infinity;\n\t\tconst l2 = trip[0].lowerTwoSigma ?? -Infinity;\n\t\tconst u3 = trip[0].upperProcessLimit ?? Infinity;\n\t\tconst l3 = trip[0].lowerProcessLimit ?? -Infinity;\n\t\tconst highs = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! > u2 : (r.value! > u2 && r.value! <= u3));\n\t\tconst lows = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! < l2 : (r.value! < l2 && r.value! >= l3));\n\t\tif (allHigh && highs.length >= 2)\n\t\t\thighs.forEach((r) => (r.twoSigmaUp = true));\n\t\tif (allLow && lows.length >= 2)\n\t\t\tlows.forEach((r) => (r.twoSigmaDown = true));\n\t}\n\n\t// Trend (strict monotonic inc/dec)\n\tfor (let w = 0; w <= idxs.length - trendN; w++) {\n\t\tconst win = idxs.slice(w, w + trendN);\n\t\tconst seq = win.map(get);\n\t\tif (!seq.every((r) => isNumber(r.value))) continue;\n\t\tlet inc = true;\n\t\tlet dec = true;\n\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\tif (!inc && !dec) break;\n\t\t}\n\t\tif (inc) win.forEach((i) => (get(i).trendUp = true));\n\t\tif (dec) win.forEach((i) => (get(i).trendDown = true));\n\t}\n}\n", "import {\n\tImprovementDirection,\n\tMetricConflictRule,\n\tPrimeDirection,\n\tSide,\n\tSpcRowV2,\n\tSpcRuleId,\n\tVariationIcon,\n} from \"./types\";\nimport { RULE_RANK_BY_ID } from \"./constants\";\n\n// Build per-side lists of active rules with numeric rank and compute the prime direction\n// by comparing the maximum rank on each side (Up vs Down), mirroring SQL's #ConflictRankingSummary.\nexport function getDirectionalSummary(row: SpcRowV2) {\n\tconst up: { id: SpcRuleId; rank: number }[] = [];\n\tconst dn: { id: SpcRuleId; rank: number }[] = [];\n\n\t// Single point and Two Sigma (separate one-sided flags)\n\tif (row.singlePointUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.singlePointDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.twoSigmaUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\tif (row.twoSigmaDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\t\n\t// Shift and Trend (no separate one-sided flags)\n\tif (row.shiftUp)\n\t\tup.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.shiftDown)\n\t\tdn.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.trendUp)\n\t\tup.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\tif (row.trendDown)\n\t\tdn.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\n\t// Determine prime direction by comparing max rank on each side\n\tconst upMax = up.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst dnMax = dn.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst primeDirection =\n\t\tupMax > dnMax\n\t\t\t? PrimeDirection.Upwards\n\t\t\t: dnMax > upMax\n\t\t\t\t? PrimeDirection.Downwards\n\t\t\t\t: PrimeDirection.Same;\n\treturn { up, dn, upMax, dnMax, primeDirection };\n}\n\n// Decide whether aligned (improvement side) and opposite (concern side) candidates exist,\n// prior to any pruning. Mirrors SQL formation of SpecialCauseImprovementValue/ConcernValue.\nexport function deriveOriginalCandidates(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection\n) {\n\t// Aligned = high side for Up metrics; low side for Down metrics\n\tconst aligned =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointDown ||\n\t\t\t\t\trow.twoSigmaDown ||\n\t\t\t\t\trow.shiftDown ||\n\t\t\t\t\trow.trendDown\n\t\t\t\t: false;\n\t\n\t// Opposite = low side for Up metrics; high side for Down metrics\n\tconst opposite =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointDown ||\n\t\t\t\trow.twoSigmaDown ||\n\t\t\t\trow.shiftDown ||\n\t\t\t\trow.trendDown\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t\t: false;\n\t\n\treturn { aligned, opposite };\n}\n\n// Apply SQL-like pruning rules when both candidates exist, using primeDirection and metricConflictRule\n// to remove one side. Also sets variationIcon to match the remaining candidate(s) and records diagnostics.\nexport function applySqlPruning(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection,\n\tmetricConflictRule: MetricConflictRule\n) {\n\t// Get directional summary (also sets row.primeDirection)\n\tconst { up, dn, upMax, dnMax, primeDirection } = getDirectionalSummary(row);\n\trow.primeDirection = primeDirection;\n\tconst originalImprovement = row.specialCauseImprovementValue;\n\tconst originalConcern = row.specialCauseConcernValue;\n\n\t// If both candidates exist, prune one side based on primeDirection and metricConflictRule\n\tif (\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\t// Prime direction wins\n\t\tif (primeDirection === PrimeDirection.Upwards) {\n\n\t\t\t// Upwards prime - remove Down candidate\n\t\t\tif (metric === ImprovementDirection.Up) \n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\telse if (metric === ImprovementDirection.Down)\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\n\t\t// No prime direction (tie) - use metricConflictRule to decide\t\n\t\t} else if (primeDirection === PrimeDirection.Downwards) {\n\t\t\tif (metric === ImprovementDirection.Up)\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\telse if (metric === ImprovementDirection.Down)\n\t\t\t\trow.specialCauseConcernValue = null;\n\n\t\t// Tie - no prime direction - use metricConflictRule to decide\n\t\t} else {\n\t\t\tif (metricConflictRule === MetricConflictRule.Improvement)\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\telse row.specialCauseImprovementValue = null;\n\t\t}\n\t}\n\n\t// Update variation icon to reflect pruned candidates\n\tif (metric === ImprovementDirection.Up) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernLow\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\n\t// Down metrics\n\t} else if (metric === ImprovementDirection.Down) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementLow\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernHigh\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\t\n\t// Neither metrics\n\t} else {\n\t\t// Neither not used in SQL conflict pruning branch\n\t\trow.variationIcon = VariationIcon.CommonCause;\n\t}\n\n\t// prime rank and winner rule id\n\tconst winningSide =\n\t\trow.specialCauseImprovementValue !== null\n\t\t\t? Side.Up\n\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t? Side.Down\n\t\t\t\t: undefined;\n\tconst winningRank =\n\t\twinningSide === Side.Up\n\t\t\t? upMax\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dnMax\n\t\t\t\t: Math.max(upMax, dnMax);\n\trow.primeRank = winningRank || undefined;\n\tconst winner =\n\t\twinningSide === Side.Up\n\t\t\t? up.find((r) => r.rank === winningRank)\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dn.find((r) => r.rank === winningRank)\n\t\t\t\t: undefined;\n\trow.primeRuleId = winner?.id;\n\n\treturn { originalImprovement, originalConcern };\n}\n", "import { AssuranceIcon, ChartType, ImprovementDirection, SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport function computeAssuranceIconXmR(\n\trow: SpcRowV2,\n\tmetricImprovement: ImprovementDirection,\n\ttarget: number | null | undefined\n): AssuranceIcon {\n\tif (\n\t\t!isNumber(target) ||\n\t\trow.mean === null ||\n\t\trow.upperProcessLimit === null ||\n\t\trow.lowerProcessLimit === null\n\t)\n\t\treturn AssuranceIcon.None;\n\tif (metricImprovement === ImprovementDirection.Up) {\n\t\tif (target <= row.lowerProcessLimit) return AssuranceIcon.Pass;\n\t\tif (target >= row.upperProcessLimit) return AssuranceIcon.Fail;\n\t\treturn AssuranceIcon.HitOrMiss;\n\t}\n\tif (metricImprovement === ImprovementDirection.Down) {\n\t\tif (target >= row.upperProcessLimit) return AssuranceIcon.Pass;\n\t\tif (target <= row.lowerProcessLimit) return AssuranceIcon.Fail;\n\t\treturn AssuranceIcon.HitOrMiss;\n\t}\n\treturn AssuranceIcon.None;\n}\n\n// Parity-facing helper: Suppress assurance for T/G and delegate to XmR logic otherwise\nexport function computeAssuranceIcon(\n\tchartType: ChartType,\n\trow: SpcRowV2,\n\tmetricImprovement: ImprovementDirection,\n\ttarget: number | null | undefined\n): AssuranceIcon {\n\tif (chartType !== ChartType.XmR) return AssuranceIcon.None;\n\treturn computeAssuranceIconXmR(row, metricImprovement, target);\n}\n", "import {\n\tBuildArgsV2,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tSpcResultV2,\n\tSpcRowV2,\n\tVariationIcon,\n} from \"./types\";\nimport { computePartitionLimits } from \"./limits\";\nimport { detectRulesInPartition } from \"./detector\";\nimport { applySqlPruning, deriveOriginalCandidates } from \"./conflict\";\nimport { isNumber } from \"./utils\";\n\n// Build an SPC result aligned to SQL v2.6a, focusing on XmR.\n// Mirrors SQL steps but emits per-row icons; dataset parity compares the last non-ghosted row.\nexport function buildSpcV26a(args: BuildArgsV2): SpcResultV2 {\n\tconst { chartType, metricImprovement, data, settings } = args;\n\t// Consolidate settings with sensible defaults derived from SQL guidance\n\tconst s = {\n\t\tminimumPoints: 13,\n\t\tshiftPoints: 6,\n\t\ttrendPoints: 6,\n\t\texcludeMovingRangeOutliers: false,\n\t\tmetricConflictRule: MetricConflictRule.Improvement,\n\t\ttrendAcrossPartitions: false,\n\t\ttwoSigmaIncludeAboveThree: false,\n\t\t...settings,\n\t};\n\n\t// Canonical rows \u2014 ensure predictable structure and types used throughout the build\n\tconst canon = data.map((d, i) => ({\n\t\trowId: i + 1,\n\t\tx: d.x,\n\t\tvalue: isNumber(d.value) ? d.value! : null,\n\t\tghost: !!d.ghost,\n\t\tbaseline: !!d.baseline,\n\t\ttarget: isNumber(d.target) ? d.target! : null,\n\t}));\n\n\t// Partitioning \u2014 split series at baseline markers (inclusive), calculations occur within these partitions\n\tconst partitions: (typeof canon)[] = [];\n\tlet cur: typeof canon = [];\n\tfor (const r of canon) {\n\t\tif (r.baseline && cur.length) {\n\t\t\tpartitions.push(cur);\n\t\t\tcur = [];\n\t\t}\n\t\tcur.push(r);\n\t}\n\tif (cur.length) partitions.push(cur);\n\n\tconst out: SpcRowV2[] = [];\n\tlet partitionId = 0;\n\tfor (const part of partitions) {\n\t\tpartitionId++;\n\t\tconst values = part.map((p) => p.value);\n\t\tconst ghosts = part.map((p) => p.ghost);\n\n\t\t// Eligibility: in parity we gate control lines per-partition, not globally\n\t\tconst eligibleInPartition = part.filter((p) => !p.ghost && isNumber(p.value)).length >= s.minimumPoints!;\n\n\t\tconst lim = computePartitionLimits(\n\t\t\tchartType,\n\t\t\tvalues,\n\t\t\tghosts,\n\t\t\t!!s.excludeMovingRangeOutliers\n\t\t);\n\n\t\tconst withLines: SpcRowV2[] = part.map((r, i) => ({\n\t\t\trowId: r.rowId,\n\t\t\tx: r.x,\n\t\t\tvalue: isNumber(r.value) ? r.value : null,\n\t\t\tghost: r.ghost,\n\t\t\tpartitionId,\n\t\t\tpointRank:\n\t\t\t\t!r.ghost && isNumber(r.value)\n\t\t\t\t\t? values.slice(0, i + 1).filter((v, j) => !ghosts[j] && isNumber(v))\n\t\t\t\t\t\t\t.length\n\t\t\t\t\t: 0,\n\t\t\tmean: eligibleInPartition && isNumber(lim.mean) ? lim.mean : null,\n\t\t\tupperProcessLimit: eligibleInPartition ? lim.upperProcessLimit : null,\n\t\t\tlowerProcessLimit: eligibleInPartition ? lim.lowerProcessLimit : null,\n\t\t\tupperTwoSigma: eligibleInPartition ? lim.upperTwoSigma : null,\n\t\t\tlowerTwoSigma: eligibleInPartition ? lim.lowerTwoSigma : null,\n\t\t\tupperOneSigma: eligibleInPartition ? lim.upperOneSigma : null,\n\t\t\tlowerOneSigma: eligibleInPartition ? lim.lowerOneSigma : null,\n\t\t\t// rules\n\t\t\tsinglePointUp: false,\n\t\t\tsinglePointDown: false,\n\t\t\ttwoSigmaUp: false,\n\t\t\ttwoSigmaDown: false,\n\t\t\tshiftUp: false,\n\t\t\tshiftDown: false,\n\t\t\ttrendUp: false,\n\t\t\ttrendDown: false,\n\t\t\t// candidates\n\t\t\tspecialCauseImprovementValue: null,\n\t\t\tspecialCauseConcernValue: null,\n\t\t\tvariationIcon: VariationIcon.CommonCause,\n\t\t}));\n\n\t\t// Pass 1: single 3-sigma \u2014 mark any point beyond upper/lower process limits\n\t\tfor (const row of withLines) {\n\t\t\tif (\n\t\t\t\t!eligibleInPartition ||\n\t\t\t\trow.ghost ||\n\t\t\t\t!isNumber(row.value) ||\n\t\t\t\trow.mean === null\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (\n\t\t\t\tisNumber(row.upperProcessLimit) &&\n\t\t\t\trow.value! > row.upperProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointUp = true;\n\t\t\tif (\n\t\t\t\tisNumber(row.lowerProcessLimit) &&\n\t\t\t\trow.value! < row.lowerProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointDown = true;\n\t\t}\n\n\t\t\t// Pass 2: patterns \u2014 shift, two-of-three, strict monotonic trend (per-partition)\n\t\t\tdetectRulesInPartition(withLines, {\n\t\t\t\tshiftPoints: s.shiftPoints!,\n\t\t\t\ttrendPoints: s.trendPoints!,\n\t\t\t\ttwoSigmaIncludeAboveThree: !!s.twoSigmaIncludeAboveThree,\n\t\t\t});\n\n\t\t// SQL candidate formation and pruning for all rows (engine v2.6a parity)\n\t\tfor (const row of withLines) {\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) {\n\t\t\t\tout.push(row);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(\n\t\t\t\trow,\n\t\t\t\tmetricImprovement\n\t\t\t);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\n\t\t\t\t\tif (metricImprovement === ImprovementDirection.Neither) {\n\t\t\t\t\t\t// Neither semantics: high-side rules -> NeitherHigh, low-side rules -> NeitherLow, else CommonCause\n\t\t\t\t\t\tconst highSide = row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp;\n\t\t\t\t\t\tconst lowSide = row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown;\n\t\t\t\t\t\trow.variationIcon = highSide ? VariationIcon.NeitherHigh : lowSide ? VariationIcon.NeitherLow : VariationIcon.CommonCause;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Up/Down metrics: apply SQL-style pruning and then set icon via pruning outcome\n\t\t\t\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!);\n\t\t\t\t\t}\n\t\t\tout.push(row);\n\t\t}\n\t}\n\n\t// Optional global trend detection across partitions (SQL v2.2+):\n\tif (s.trendAcrossPartitions) {\n\t\t// Build a flat, ordered index of all non-ghost, valued rows\n\t\tconst all = out.map((r, i) => ({ idx: i, r })).filter(({ r }) => !r.ghost && isNumber(r.value));\n\t\tif (all.length >= s.trendPoints!) {\n\t\t\tfor (let w = 0; w <= all.length - s.trendPoints!; w++) {\n\t\t\t\tconst win = all.slice(w, w + s.trendPoints!).map((p) => p.idx);\n\t\t\t\tconst seq = win.map((i) => out[i]);\n\t\t\t\tif (!seq.every((row) => isNumber(row.value))) continue;\n\t\t\t\tlet inc = true;\n\t\t\t\tlet dec = true;\n\t\t\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\t\t\tif (!inc && !dec) break;\n\t\t\t\t}\n\t\t\t\tif (inc) win.forEach((i) => (out[i].trendUp = true));\n\t\t\t\tif (dec) win.forEach((i) => (out[i].trendDown = true));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { rows: out };\n}\n\nexport default { buildSpcV26a };\n", "import { MetricConflictRule, SpcSettingsV26a } from \"./types\";\n\n// SQL v2.6 parity preset (with trend across partitions from SQL v2.2 note)\nexport const PARITY_V26: Readonly<SpcSettingsV26a> = Object.freeze({\n\tminimumPoints: 13,\n\tshiftPoints: 6,\n\ttrendPoints: 6,\n\texcludeMovingRangeOutliers: false,\n\tmetricConflictRule: MetricConflictRule.Improvement,\n\ttrendAcrossPartitions: true,\n\ttwoSigmaIncludeAboveThree: true,\n});\n\nexport function withParityV26(overrides?: SpcSettingsV26a): SpcSettingsV26a {\n\treturn { ...PARITY_V26, ...(overrides ?? {}) };\n}\n\nexport default { PARITY_V26, withParityV26 };\n"],
  "mappings": "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",
  "names": ["ChartType", "ImprovementDirection", "VariationIcon", "AssuranceIcon", "SpcRuleId", "PrimeDirection", "Side", "MetricConflictRule", "mean"]
}
