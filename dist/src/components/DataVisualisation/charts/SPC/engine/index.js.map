{
  "version": 3,
  "sources": ["../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/types.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/constants.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/utils.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/limits.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/detector.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/conflict.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/trendSegments.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/visualCategories.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/boundaryWindows.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/normaliser.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/engine.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/presets.ts", "../../../../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/retroOverlay.ts"],
  "sourcesContent": ["// Strongly-typed enums and core types mirroring SQL v2.6a naming.\n// These names are chosen to be easy to cross-reference with the SQL script and docs.\n\n// Supported chart types \u2014 v2.6a parity focuses on XmR; T and G can be added as needed\nexport enum ChartType {\n\tXmR = \"XmR\",\n\tT = \"T\",\n\tG = \"G\",\n}\n\n// How a metric is judged: higher is better, lower is better, or neither (neutral)\nexport enum ImprovementDirection {\n\tUp = \"Up\",\n\tDown = \"Down\",\n\tNeither = \"Neither\",\n}\n\n// Variation icon classification used for testing parity against SQL.\n// SQL v2.6a emits icons only for the last point, but we retain a per-row value for convenience.\nexport enum VariationIcon {\n\tImprovementHigh = \"ImprovementHigh\", // improvement on the high side (metric Up)\n\tImprovementLow = \"ImprovementLow\", // improvement on the low side (metric Down)\n\tConcernHigh = \"ConcernHigh\", // concern on the high side (metric Down)\n\tConcernLow = \"ConcernLow\", // concern on the low side (metric Up)\n\tNeitherHigh = \"NeitherHigh\", // neutral with a high-side special cause for Neither metrics\n\tNeitherLow = \"NeitherLow\", // neutral with a low-side special cause for Neither metrics\n\tCommonCause = \"CommonCause\", // no special cause detected contributing to icon\n}\n\n// Assurance outcome relative to target and process limits (XmR only in this module)\nexport enum AssuranceIcon {\n\tNone = \"None\",\n\tPass = \"Pass\",\n\tHitOrMiss = \"HitOrMiss\",\n\tFail = \"Fail\",\n}\n\n// Identifiers for rule types used in ranking and diagnostics\nexport enum SpcRuleId {\n\tSinglePoint = \"SinglePoint\",\n\tTwoSigma = \"TwoSigma\",\n\tShift = \"Shift\",\n\tTrend = \"Trend\",\n}\n\n// Direction determined by comparing the strongest rule rank on each side\nexport enum PrimeDirection {\n\tUpwards = \"Upwards\",\n\tDownwards = \"Downwards\",\n\tSame = \"Same\",\n}\n\n// Convenience to describe which side of the mean a signal sits on\nexport enum Side {\n\tUp = \"Up\",\n\tDown = \"Down\",\n}\n\n// Policy to apply when PrimeDirection is Same and both candidates exist\nexport enum MetricConflictRule {\n\tImprovement = \"Improvement\",\n\tConcern = \"Concern\",\n}\n\n// Strategy for resolving conflicts when both improvement and concern candidates exist\nexport enum ConflictStrategy {\n\t// Maintain SQL v2.6a parity: use PrimeDirection first, then MetricConflictRule only when PrimeDirection is Same\n\tSqlPrimeThenRule = \"SqlPrimeThenRule\",\n\t// Excel-style: always prefer the improvement side when a conflict exists (ignores PrimeDirection)\n\tPreferImprovement = \"PreferImprovement\",\n\t// Custom rule hierarchy: choose the side that contains the highest-precedence rule from a provided order\n\tRuleHierarchy = \"RuleHierarchy\",\n}\n\n// Strategy to select which mean-side trend segment(s) participate after splitting a run at crossings - integral for special cause conflict resolution\nexport enum TrendSegmentationStrategy {\n\t// Highlight all favourable-side segments\n\tFavourableSide = \"FavourableSide\",\n\t// Highlight the first favourable-side segment that occurs after a crossing; if no crossing occurred,\n\t// fall back to the longest favourable-side segment (by length)\n\tCrossingAfterFavourable = \"CrossingAfterFavourable\",\n\t// Highlight the favourable-side segment with the greatest absolute distance from mean\n\tExtremeFavourable = \"ExtremeFavourable\",\n\t// Always pick the first favourable-side segment in the run (chronological)\n\tFirstFavourable = \"FirstFavourable\",\n\t// Pick the longest favourable-side segment by length (ties broken by earliest)\n\tLongestFavourable = \"LongestFavourable\",\n\t// Pick the last favourable-side segment in the run (chronological)\n\tLastFavourable = \"LastFavourable\",\n\t// Unfavourable variants \u2014 mirror the above but for the opposite mean side\n\tUnfavourableSide = \"UnfavourableSide\",\n\t// Highlight the first unfavourable-side segment that occurs after a crossing; if no crossing occurred, fall back to the longest unfavourable-side segment (by length)\n\tCrossingAfterUnfavourable = \"CrossingAfterUnfavourable\",\n\t// Highlight the unfavourable-side segment with the greatest absolute distance from mean\n\tExtremeUnfavourable = \"ExtremeUnfavourable\",\n\t// Always pick the first unfavourable-side segment in the run (chronological)\n\tFirstUnfavourable = \"FirstUnfavourable\",\n\t// Pick the longest unfavourable-side segment by length (ties broken by earliest)\n\tLongestUnfavourable = \"LongestUnfavourable\",\n\t// Pick the last unfavourable-side segment in the run (chronological)\n\tLastUnfavourable = \"LastUnfavourable\",\n}\n\n// Controls when favourable trend segmentation should apply\nexport enum TrendSegmentationMode {\n\t// Do not apply segmentation at all\n\tOff = \"Off\",\n\t// Apply segmentation automatically only when a conflict is detected in the series/partition\n\tAutoWhenConflict = \"AutoWhenConflict\",\n\t// Always apply segmentation regardless of conflicts (legacy boolean=true behaviour)\n\tAlways = \"Always\",\n}\n\n// The input row shape accepted by the engine\nexport interface SpcInputRowV2 {\n\tx: string | number | Date;\n\tvalue?: number | null;\n\tghost?: boolean;\n\tbaseline?: boolean;\n\ttarget?: number | null;\n}\n\n// Settings that influence rule thresholds and pruning behaviour\n// Flat v2.6a settings (back-compat). Consider using the hierarchical form below for more semantic grouping.\nexport interface SpcSettingsV26a {\n\tminimumPoints?: number; // global gating\n\tshiftPoints?: number; // default 6\n\ttrendPoints?: number; // default 6\n\texcludeMovingRangeOutliers?: boolean; // default false\n\tmetricConflictRule?: MetricConflictRule; // default Improvement (tie-break when PrimeDirection is Same)\n\t// Parity-specific controls\n\ttrendAcrossPartitions?: boolean; // default false (SQL v2.2+ enables; preset turns on)\n\ttwoSigmaIncludeAboveThree?: boolean; // default false (preset turns on)\n\t// Optional early warning rule (excluded from conflict ranking)\n\tenableFourOfFiveRule?: boolean; // default false\n\t// Conflict handling: when both improvement and concern candidates\n\t// exist for a point (typically due to trend crossing the mean), prefer keeping\n\t// the improvement side regardless of PrimeDirection. Default false to retain\n\t// SQL v2.6a parity (PrimeDirection first, then MetricConflictRule only on ties).\n\t// NOTE: When this flag is true, the engine disables favourable trend segmentation\n\t// (both per-partition and across partitions). As a consequence, segmentation-dependent\n\t// controls like `preferTrendWhenConflict` and `trendDominatesHighlightedWindow` will have\n\t// no effect for those rows because no highlighted trend window is established.\n\tpreferImprovementWhenConflict?: boolean;\n\t// Configurable conflict resolution strategy; default keeps SQL parity.\n\tconflictStrategy?: ConflictStrategy;\n\t// When true, if both improvement and concern candidates exist on a row and one of the trend flags\n\t// (trendUp/trendDown) is present after segmentation, prefer the trend side and prune the other.\n\t// This helps datasets where a trend segment should dominate over non-trend rules within its window.\n\tpreferTrendWhenConflict?: boolean;\n\t// When using ConflictStrategy.RuleHierarchy, precedence order for rules from highest to lowest\n\t// Default mirrors SQL ranking: Trend > Shift > TwoSigma > SinglePoint\n\truleHierarchy?: SpcRuleId[];\n\t// When true, once the chart has at least `minimumPoints` non-ghosted values overall,\n\t// compute limits and evaluate rules across entire partitions (retrospective colouring of early rows).\n\t// When false (default), eligibility is per-point (prospective) using pointRank.\n\tchartLevelEligibility?: boolean;\n\t// When true (default), after trend flags are backfilled, split runs at mean crossings and\n\t// keep only favourable-side segments for contribution to classification, using a strategy.\n\t// This resolves Special-cause conflicts when a run crosses the mean by recoding the pre-crossing\n\t// segment to not participate in variation classification.\n\t// Deprecated: prefer trendSegmentationMode. If provided, `true` maps to `Always`, `false` maps to `Off`.\n\ttrendFavourableSegmentation?: boolean;\n\t// When and how to apply favourable trend segmentation. Default behaviour is `AutoWhenConflict` to\n\t// minimise impact on datasets without conflicts while resolving cross-mean trend conflicts when present.\n\ttrendSegmentationMode?: TrendSegmentationMode;\n\t// When true, within highlighted trend segments (post-segmentation), drop opposite-side non-trend\n\t// rule flags (singlePoint/twoSigma/shift) so the highlighted trend segment dominates classification\n\t// in its window. Default false to preserve SQL parity. Works independently of preferTrendWhenConflict\n\t// by manipulating rule flags earlier in the pipeline. Has no effect when\n\t// `preferImprovementWhenConflict` is true (segmentation disabled by engine gating).\n\ttrendDominatesHighlightedWindow?: boolean;\n\t// Strategy for picking which favourable-side segment(s) to keep when a run crosses the mean.\n\t// Default: TrendSegmentationStrategy.CrossingAfterFavourable \u2014 first favourable segment after crossing, else longest favourable.\n\ttrendSegmentationStrategy?: TrendSegmentationStrategy;\n}\n\n// Hierarchical settings (semantic grouping). Shipped alongside a normaliser for back-compat.\nexport interface SpcSettingsHierarchical {\n\tthresholds?: {\n\t\t/** Minimum non-ghost points required to enable limits/rules (per partition by default). */\n\t\tminimumPoints?: number;\n\t\t/** Shift run length (default 6). */\n\t\tshiftPoints?: number;\n\t\t/** Trend run length (default 6). */\n\t\ttrendPoints?: number;\n\t\t/** Exclude MR outliers when estimating sigma (XmR). */\n\t\texcludeMovingRangeOutliers?: boolean;\n\t};\n\teligibility?: {\n\t\t/** If true, once chart has >= minimumPoints overall, evaluate across partitions retroactively. */\n\t\tchartLevel?: boolean;\n\t};\n\tparity?: {\n\t\t/** Enable strict trend detection across partitions (SQL v2.2+). */\n\t\ttrendAcrossPartitions?: boolean;\n\t\t/** Count >3\u03C3 points toward the two-of-three rule. */\n\t\ttwoSigmaIncludeAboveThree?: boolean;\n\t\t/** Enable optional early-warning rule: 4-of-5 beyond 1\u03C3 (excluded from ranking). */\n\t\tenableFourOfFiveRule?: boolean;\n\t};\n\tconflict?: {\n\t\t/** Optimistically keep Improvement when both sides exist (disables trend segmentation). */\n\t\tpreferImprovementWhenConflict?: boolean;\n\t\t/** Prefer the trend side when both sides exist and a trend flag is present after segmentation. */\n\t\tpreferTrendWhenConflict?: boolean;\n\t\t/** Strategy for conflict resolution (default SQL parity). */\n\t\tstrategy?: ConflictStrategy;\n\t\t/** Optional rule precedence order (used with strategy RuleHierarchy). */\n\t\truleHierarchy?: SpcRuleId[];\n\t\t/** Tie-break rule when PrimeDirection is Same. */\n\t\tmetricRuleOnTie?: MetricConflictRule;\n\t};\n\ttrend?: {\n\t\tsegmentation?: {\n\t\t\t/** When to apply favourable-side segmentation. Prefer this over the legacy boolean. */\n\t\t\tmode?: TrendSegmentationMode;\n\t\t\t/** Legacy alias (true -> Always, false -> Off). */\n\t\t\tfavourableSegmentation?: boolean;\n\t\t\t/** Strategy to pick which favourable segment(s) to keep. */\n\t\t\tstrategy?: TrendSegmentationStrategy;\n\t\t\t/** If true, trend dominates inside its highlighted window. */\n\t\t\tdominatesHighlightedWindow?: boolean;\n\t\t};\n\t};\n}\n\n// Settings input accepted by public APIs: flat (legacy) or hierarchical (preferred)\nexport type SpcSettingsInput = SpcSettingsV26a | SpcSettingsHierarchical;\n\n// The fully computed row emitted by the engine\nexport interface SpcRowV2 {\n\trowId: number;\n\tx: string | number | Date;\n\tvalue: number | null;\n\tghost: boolean;\n\tpartitionId: number;\n\tpointRank: number;\n\tmean: number | null;\n\tupperProcessLimit: number | null;\n\tlowerProcessLimit: number | null;\n\tupperTwoSigma: number | null;\n\tlowerTwoSigma: number | null;\n\tupperOneSigma: number | null;\n\tlowerOneSigma: number | null;\n\t// Rule flags (directional)\n\tsinglePointUp: boolean;\n\tsinglePointDown: boolean;\n\ttwoSigmaUp: boolean;\n\ttwoSigmaDown: boolean;\n\tfourOfFiveUp: boolean;\n\tfourOfFiveDown: boolean;\n\tshiftUp: boolean;\n\tshiftDown: boolean;\n\ttrendUp: boolean;\n\ttrendDown: boolean;\n\t// Candidate values (post-pruning optional)\n\tspecialCauseImprovementValue: number | null;\n\tspecialCauseConcernValue: number | null;\n\t// Summary (per-row for testing convenience)\n\tvariationIcon: VariationIcon;\n\t// Diagnostics\n\tprimeDirection?: PrimeDirection;\n\tprimeRank?: number;\n\tprimeRuleId?: SpcRuleId;\n}\n\n// The arguments to build an SPC result\nexport interface BuildArgsV2 {\n\tchartType: ChartType;\n\tmetricImprovement: ImprovementDirection;\n\tdata: SpcInputRowV2[];\n\t/**\n\t * Settings may be provided in flat (v2.6a) or hierarchical form. The engine normalises these.\n\t */\n\tsettings?: SpcSettingsInput;\n}\n\n// The build result containing all rows (warnings kept separate for clarity in this module)\nexport interface SpcResultV2 {\n\trows: SpcRowV2[];\n}\n\n// ------------------------- Warning metadata (shared with chart UI) -------------------------\n// These mirror the legacy v1 enums but live alongside v2 so SPCChart can consume\n// them without depending on the v1 module.\nexport enum SpcWarningSeverity {\n\tInfo = \"info\",\n\tWarning = \"warning\",\n\tError = \"error\",\n}\n\nexport enum SpcWarningCategory {\n\tConfig = \"config\",\n\tData = \"data\",\n\tLimits = \"limits\",\n\tSpecialCause = \"special_cause\",\n\tBaseline = \"baseline\",\n\tLogic = \"logic\",\n\tTarget = \"target\",\n\tGhost = \"ghost\",\n\tPartition = \"partition\",\n}\n\n// Stable catalog of warning codes (public surface)\nexport enum SpcWarningCode {\n\tUnknownChartType = 'unknown_chart_type',\n\tInsufficientPointsGlobal = 'insufficient_points_global',\n\tVariationConflictRow = 'variation_conflict_row',\n\tNullValuesExcluded = 'null_values_excluded',\n\tTargetIgnoredRareEvent = 'target_ignored_rare_event',\n\tGhostRowsRareEvent = 'ghost_rows_rare_event',\n\tInsufficientPointsPartition = 'insufficient_points_partition',\n\tBaselineWithSpecialCause = 'baseline_with_special_cause',\n\tPartitionCapApplied = 'partition_cap_applied',\n\tGlobalCapApplied = 'global_cap_applied',\n}\n\nexport interface SpcWarning {\n\tcode: SpcWarningCode; // stable identifier\n\tmessage: string; // human-readable text\n\tseverity?: SpcWarningSeverity;\n\tcategory?: SpcWarningCategory;\n\tcontext?: Record<string, unknown>; // optional structured data (counts, ids, etc.)\n}\n", "import { SpcRuleId } from \"./types\";\n\n// Higher number = higher precedence (stronger rule).\n// Align exactly with SQL v2.6a conflict ranking used to compute PrimeDirection:\n// Trend (4) > Shift (3) > TwoSigma (2) > SinglePoint (1)\nexport const RULE_RANK_BY_ID: Record<SpcRuleId, number> = {\n\t[SpcRuleId.SinglePoint]: 1,\n\t[SpcRuleId.TwoSigma]: 2,\n\t[SpcRuleId.Shift]: 3,\n\t[SpcRuleId.Trend]: 4,\n};\n\n// XmR constants to mirror standard SPC formulas (SQL v2.6a parity)\n// d2 for n=2\nexport const D2 = 1.128 as const;\n// Moving range UCL factor\nexport const MR_UCL_FACTOR = 3.267 as const;\n// 3\u03C3 factor for XmR limits: mean \u00B1 2.66 * MRbar\nexport const XMR_THREE_SIGMA_FACTOR = 2.66 as const;\n\n// T-chart transform exponent (SQL v2.6a): y = t^T_EXP, limits computed in y-space, then back-transformed\nexport const T_TRANSFORM_EXP = 0.2777 as const;\n", "// A small helper to check a value is a proper finite number.\nimport { MR_UCL_FACTOR, XMR_THREE_SIGMA_FACTOR } from \"./constants\";\n\nexport function isNumber(n: unknown): n is number {\n\treturn typeof n === \"number\" && !Number.isNaN(n);\n}\n\n// Arithmetic mean of a numeric array. Returns 0 when empty to avoid NaN.\nexport function mean(nums: number[]): number {\n\treturn nums.reduce((a, b) => a + b, 0) / (nums.length || 1);\n}\n\n// Compute moving ranges against the previous non-ghosted numeric value, returning null when not applicable.\nexport function movingRanges(\n\tvalues: (number | null | undefined)[],\n\tghosts: boolean[]\n): (number | null)[] {\n\tconst mr: (number | null)[] = new Array(values.length).fill(null);\n\tlet lastIdx: number | null = null;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tconst v = values[i];\n\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\tif (lastIdx !== null) {\n\t\t\tconst prev = values[lastIdx];\n\t\t\tif (isNumber(prev)) mr[i] = Math.abs(v - prev);\n\t\t}\n\t\tlastIdx = i;\n\t}\n\treturn mr;\n}\n\n// Compute MR mean with an optional single-pass exclusion of values above the UCL (3.267 * MRbar),\n// mirroring the SQL behaviour when moving range outlier removal is enabled.\nexport function mrMeanWithOptionalExclusion(\n\tmr: (number | null)[],\n\texcludeOutliers: boolean\n): { mrMean: number; mrUcl: number } {\n\tconst vals = mr.filter(isNumber) as number[];\n\tif (!vals.length) return { mrMean: NaN, mrUcl: NaN };\n\tlet arr = vals.slice();\n\tif (excludeOutliers) {\n\t\tconst meanMr = mean(arr);\n\t\tconst ucl = MR_UCL_FACTOR * meanMr; // standard MR UCL\n\t\tarr = arr.filter((v) => v <= ucl);\n\t}\n\tconst mrMean = mean(arr);\n\treturn { mrMean, mrUcl: MR_UCL_FACTOR * mrMean };\n}\n\n// Given a centre line and MR mean, return standard XmR limits and 1\u03C3/2\u03C3 bands.\nexport function xmrLimits(center: number, mrMean: number) {\n\t// When mrMean is 0 (flat series), produce zero-width limits at the center line\n\t// instead of nulls so partitions with no variation still render control lines.\n\tif (!isNumber(center) || !isNumber(mrMean)) {\n\t\treturn {\n\t\t\tupperProcessLimit: null,\n\t\t\tlowerProcessLimit: null,\n\t\t\tupperTwoSigma: null,\n\t\t\tlowerTwoSigma: null,\n\t\t\tupperOneSigma: null,\n\t\t\tlowerOneSigma: null,\n\t\t};\n\t}\n\tconst threeSigma = XMR_THREE_SIGMA_FACTOR * mrMean;\n\tconst twoSigma = (2 / 3) * threeSigma;\n\tconst oneSigma = (1 / 3) * threeSigma;\n\treturn {\n\t\tupperProcessLimit: center + threeSigma,\n\t\tlowerProcessLimit: center - threeSigma,\n\t\tupperTwoSigma: center + twoSigma,\n\t\tlowerTwoSigma: center - twoSigma,\n\t\tupperOneSigma: center + oneSigma,\n\t\tlowerOneSigma: center - oneSigma,\n\t};\n}\n", "import {\n\tisNumber,\n\tmean,\n\tmovingRanges,\n\tmrMeanWithOptionalExclusion,\n\txmrLimits,\n} from \"./utils\";\nimport { ChartType } from \"./types\";\nimport { T_TRANSFORM_EXP } from \"./constants\";\n\n// Compute control lines for a single partition based on chart type.\n// For v2.6a parity we focus on XmR here; T and G can be added later.\nexport function computePartitionLimits(\n\tchartType: ChartType,\n\tvalues: (number | null)[],\n\tghosts: boolean[],\n\texcludeMovingRangeOutliers: boolean\n) {\n\t// T chart: transform-positive values with exponent, compute XmR in y-space, back-transform control lines\n\tif (chartType === ChartType.T) {\n\t\tconst yVals: (number | null)[] = values.map((v) => (isNumber(v) && v! > 0 ? Math.pow(v!, T_TRANSFORM_EXP) : null));\n\t\tconst mr = movingRanges(yVals, ghosts);\n\t\tconst mrStats = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\t\t// Center: mean of eligible transformed values (exclude null/ghost)\n\t\tconst eligible = yVals.filter((v, i) => !ghosts[i] && isNumber(v)) as number[];\n\t\tconst centerY = eligible.length ? mean(eligible) : NaN;\n\t\tconst limY = xmrLimits(centerY, mrStats.mrMean);\n\t\t// Back-transform helper\n\t\tconst inv = (y: number | null) => (isNumber(y) && y! > 0 ? Math.pow(y!, 1 / T_TRANSFORM_EXP) : null);\n\t\tconst upl = isNumber(limY.upperProcessLimit) ? inv(limY.upperProcessLimit) : null;\n\t\tconst lpl = isNumber(limY.lowerProcessLimit) && limY.lowerProcessLimit > 0 ? inv(limY.lowerProcessLimit) : null; // suppress when Y-limit <= 0\n\t\tconst u2 = isNumber(limY.upperTwoSigma) ? inv(limY.upperTwoSigma) : null;\n\t\tconst l2 = isNumber(limY.lowerTwoSigma) && limY.lowerTwoSigma > 0 ? inv(limY.lowerTwoSigma) : null; // suppress when Y-limit <= 0\n\t\tconst u1 = isNumber(limY.upperOneSigma) ? inv(limY.upperOneSigma) : null;\n\t\tconst l1 = isNumber(limY.lowerOneSigma) && limY.lowerOneSigma > 0 ? inv(limY.lowerOneSigma) : null; // suppress when Y-limit <= 0\n\t\treturn {\n\t\t\tmean: isNumber(centerY) && centerY > 0 ? inv(centerY) : null,\n\t\t\tmr,\n\t\t\tmrMean: mrStats.mrMean,\n\t\t\tmrUcl: mrStats.mrUcl,\n\t\t\tupperProcessLimit: upl,\n\t\t\tlowerProcessLimit: lpl,\n\t\t\tupperTwoSigma: u2,\n\t\t\tlowerTwoSigma: l2,\n\t\t\tupperOneSigma: u1,\n\t\t\tlowerOneSigma: l1,\n\t\t};\n\t}\n\n\tif (chartType === ChartType.G) {\n\t\t// Geometric distribution based limits for count-between-events (support includes 0)\n\t\t// Compute sample mean m from eligible (non-ghost, numeric) counts\n\t\tconst eligible = values.filter((v, i) => !ghosts[i] && isNumber(v)) as number[];\n\t\tconst m = eligible.length ? mean(eligible) : NaN;\n\t\t// Convert mean to geometric parameter for 0-based support: mean = (1-p)/p => p = 1/(m+1)\n\t\tconst p = isNumber(m) ? 1 / (m + 1) : NaN;\n\t\t// Quantile function for 0-based geometric: Q(q) = ceil(log(1-q)/log(1-p)) - 1\n\t\tconst qgeom = (q: number) => {\n\t\t\tif (!isNumber(p) || p <= 0 || p >= 1) return NaN;\n\t\t\tconst k = Math.ceil(Math.log(1 - q) / Math.log(1 - p)) - 1;\n\t\t\treturn Math.max(0, k);\n\t\t};\n\t\t// Normal 3\u03C3-equivalent tail ~ 0.00135\n\t\tconst qLower3 = 0.00135;\n\t\tconst qUpper3 = 1 - 0.00135;\n\t\t// 2\u03C3-equivalent tails ~ 0.02275 / 0.97725\n\t\tconst qLower2 = 0.02275;\n\t\tconst qUpper2 = 1 - 0.02275;\n\t\t// 1\u03C3-equivalent tails ~ 0.158655 / 0.841345\n\t\tconst qLower1 = 0.158655;\n\t\tconst qUpper1 = 1 - 0.158655;\n\n\t\tconst upl = qgeom(qUpper3);\n\t\tconst lpl = qgeom(qLower3); // already clamped to >= 0\n\t\tconst u2 = qgeom(qUpper2);\n\t\tconst l2 = qgeom(qLower2);\n\t\tconst u1 = qgeom(qUpper1);\n\t\tconst l1 = qgeom(qLower1);\n\n\t\treturn {\n\t\t\tmean: isNumber(m) ? m : null,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: isNumber(upl) ? upl : null,\n\t\t\tlowerProcessLimit: isNumber(lpl) ? lpl : null,\n\t\t\tupperTwoSigma: isNumber(u2) ? u2 : null,\n\t\t\tlowerTwoSigma: isNumber(l2) ? l2 : null,\n\t\t\tupperOneSigma: isNumber(u1) ? u1 : null,\n\t\t\tlowerOneSigma: isNumber(l1) ? l1 : null,\n\t\t};\n\t}\n\tif (chartType !== ChartType.XmR) {\n\t\t// Other types not implemented\n\t\treturn {\n\t\t\tmean: NaN,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: null as number | null,\n\t\t\tlowerProcessLimit: null as number | null,\n\t\t\tupperTwoSigma: null as number | null,\n\t\t\tlowerTwoSigma: null as number | null,\n\t\t\tupperOneSigma: null as number | null,\n\t\t\tlowerOneSigma: null as number | null,\n\t\t};\n\t}\n\n\tconst mr = movingRanges(values, ghosts);\n\t// Raw MR mean/UCL used for determining which value points are excluded from the centre-line\n\tconst mrVals = mr.filter(isNumber) as number[];\n\tconst rawMrMean = mrVals.length ? mean(mrVals) : NaN;\n\tconst rawMrUcl = isNumber(rawMrMean) ? 3.267 * rawMrMean : NaN;\n\n\t// Compute centre line: optionally exclude values whose MR exceeds the RAW MR UCL (include first valued point where MR is null)\n\tlet center: number = NaN;\n\t{\n\t\tconst eligibleVals = values.reduce<number[]>((acc, v, i) => {\n\t\t\t// Skip ghosts and non-numeric values\n\t\t\tif (ghosts[i] || !isNumber(v)) return acc;\n\t\t\t// If not excluding MR outliers, include directly\n\t\t\tif (!excludeMovingRangeOutliers) {\n\t\t\t\tacc.push(v as number);\n\t\t\t\treturn acc;\n\t\t\t}\n\t\t\t// Otherwise, include when MR is null (first eligible point) or MR <= raw UCL\n\t\t\tconst mri = mr[i];\n\t\t\tif (mri === null || !isNumber(rawMrUcl) || (isNumber(mri) && mri <= rawMrUcl)) {\n\t\t\t\tacc.push(v as number);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t\tcenter = eligibleVals.length ? mean(eligibleVals) : NaN;\n\t}\n\n\t// MR mean used for limits may itself exclude MR outliers (trim then recompute MRbar and UCL)\n\tconst tmp = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\tconst lim = xmrLimits(center, tmp.mrMean);\n\treturn {\n\t\tmean: center,\n\t\tmr,\n\t\tmrMean: tmp.mrMean,\n\t\tmrUcl: tmp.mrUcl,\n\t\t...lim,\n\t};\n}\n", "import { SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface DetectorConfig {\n\tshiftPoints: number;\n\ttrendPoints: number;\n\ttwoSigmaIncludeAboveThree?: boolean;\n\tenableFourOfFiveRule?: boolean;\n}\n\nexport function detectRulesInPartition(rows: SpcRowV2[], cfg: DetectorConfig) {\n\tconst idxs = rows\n\t\t.map((_, i) => i)\n\t\t.filter((i) => !rows[i].ghost && isNumber(rows[i].value));\n\tconst get = (i: number) => rows[i];\n\tconst shiftN = cfg.shiftPoints;\n\tconst trendN = cfg.trendPoints;\n\n\t// Shift\n\tlet runHigh: number[] = [];\n\tlet runLow: number[] = [];\n\tfor (const i of idxs) {\n\t\tconst r = get(i);\n\t\tif (!isNumber(r.mean) || !isNumber(r.value)) {\n\t\t\t// reset on ineligible rows and skip marking\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t} else if (r.value > r.mean) {\n\t\t\trunHigh.push(i);\n\t\t\trunLow = [];\n\t\t} else if (r.value < r.mean) {\n\t\t\trunLow.push(i);\n\t\t\trunHigh = [];\n\t\t} else {\n\t\t\t// equal to mean breaks both runs\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t}\n\t\tif (runHigh.length >= shiftN)\n\t\t\tfor (const j of runHigh) get(j).shiftUp = true;\n\t\tif (runLow.length >= shiftN)\n\t\t\tfor (const j of runLow) get(j).shiftDown = true;\n\t}\n\n\t// Two-of-three beyond 2\u03C3 (side-consistent)\n\tfor (let w = 0; w <= idxs.length - 3; w++) {\n\t\tconst win = idxs.slice(w, w + 3);\n\t\tconst trip = win.map(get);\n\t\tif (!trip.every((r) => isNumber(r.value) && isNumber(r.mean))) {\n\t\t\t// no marking when any value/mean missing\n\t\t\tcontinue;\n\t\t}\n\t\tconst mean = trip[0].mean!;\n\t\tconst allHigh = trip.every((r) => r.value! > mean);\n\t\tconst allLow = trip.every((r) => r.value! < mean);\n\t\tif (!allHigh && !allLow) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst u2 = trip[0].upperTwoSigma ?? Infinity;\n\t\tconst l2 = trip[0].lowerTwoSigma ?? -Infinity;\n\t\tconst u3 = trip[0].upperProcessLimit ?? Infinity;\n\t\tconst l3 = trip[0].lowerProcessLimit ?? -Infinity;\n\t\tconst highs = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! > u2 : (r.value! > u2 && r.value! <= u3));\n\t\tconst lows = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! < l2 : (r.value! < l2 && r.value! >= l3));\n\t\tif (allHigh && highs.length >= 2)\n\t\t\thighs.forEach((r) => (r.twoSigmaUp = true));\n\t\tif (allLow && lows.length >= 2)\n\t\t\tlows.forEach((r) => (r.twoSigmaDown = true));\n\t}\n\n\t// Four-of-five beyond 1\u03C3 (side-consistent, optional early-warning)\n\tif (cfg.enableFourOfFiveRule) {\n\t\tfor (let w = 0; w <= idxs.length - 5; w++) {\n\t\t\tconst win = idxs.slice(w, w + 5);\n\t\t\tconst quint = win.map(get);\n\t\t\tif (!quint.every((r) => isNumber(r.value) && isNumber(r.mean))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst mean = quint[0].mean!;\n\t\t\tconst allHigh = quint.every((r) => r.value! > mean);\n\t\t\tconst allLow = quint.every((r) => r.value! < mean);\n\t\t\tif (!allHigh && !allLow) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst u1 = quint[0].upperOneSigma ?? Infinity;\n\t\t\tconst l1 = quint[0].lowerOneSigma ?? -Infinity;\n\t\t\tconst highs = quint.filter((r) => r.value! > u1);\n\t\t\tconst lows = quint.filter((r) => r.value! < l1);\n\t\t\tif (allHigh && highs.length >= 4) highs.forEach((r) => (r.fourOfFiveUp = true));\n\t\t\tif (allLow && lows.length >= 4) lows.forEach((r) => (r.fourOfFiveDown = true));\n\t\t}\n\t}\n\n\t// Trend (strict monotonic inc/dec)\n\tfor (let w = 0; w <= idxs.length - trendN; w++) {\n\t\tconst win = idxs.slice(w, w + trendN);\n\t\tconst seq = win.map(get);\n\t\tif (!seq.every((r) => isNumber(r.value))) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet inc = true;\n\t\tlet dec = true;\n\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\tif (!inc && !dec) break;\n\t\t}\n\t\tif (inc) win.forEach((i) => (get(i).trendUp = true));\n\t\tif (dec) win.forEach((i) => (get(i).trendDown = true));\n\t}\n}\n", "import {\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tPrimeDirection,\n\tSide,\n\tSpcRowV2,\n\tSpcRuleId,\n\tVariationIcon,\n} from \"./types\";\nimport { RULE_RANK_BY_ID } from \"./constants\";\n\n// Build per-side lists of active rules with numeric rank and compute the prime direction\n// by comparing the maximum rank on each side (Up vs Down), mirroring SQL's #ConflictRankingSummary.\nexport function getDirectionalSummary(row: SpcRowV2) {\n\tconst up: { id: SpcRuleId; rank: number }[] = [];\n\tconst dn: { id: SpcRuleId; rank: number }[] = [];\n\n\t// Single point and Two Sigma (separate one-sided flags)\n\tif (row.singlePointUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.singlePointDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.twoSigmaUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\tif (row.twoSigmaDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\t\n\t// Shift and Trend (no separate one-sided flags)\n\tif (row.shiftUp)\n\t\tup.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.shiftDown)\n\t\tdn.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.trendUp)\n\t\tup.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\tif (row.trendDown)\n\t\tdn.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\n\t// Determine prime direction by comparing max rank on each side\n\tconst upMax = up.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst dnMax = dn.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst primeDirection =\n\t\tupMax > dnMax\n\t\t\t? PrimeDirection.Upwards\n\t\t\t: dnMax > upMax\n\t\t\t\t? PrimeDirection.Downwards\n\t\t\t\t: PrimeDirection.Same;\n\treturn { up, dn, upMax, dnMax, primeDirection };\n}\n\n// Decide whether aligned (improvement side) and opposite (concern side) candidates exist,\n// prior to any pruning. Mirrors SQL formation of SpecialCauseImprovementValue/ConcernValue.\nexport function deriveOriginalCandidates(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection\n) {\n\t// Aligned = high side for Up metrics; low side for Down metrics\n\tconst aligned =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointDown ||\n\t\t\t\t\trow.twoSigmaDown ||\n\t\t\t\t\trow.shiftDown ||\n\t\t\t\t\trow.trendDown\n\t\t\t\t: false;\n\t\n\t// Opposite = low side for Up metrics; high side for Down metrics\n\tconst opposite =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointDown ||\n\t\t\t\trow.twoSigmaDown ||\n\t\t\t\trow.shiftDown ||\n\t\t\t\trow.trendDown\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t\t: false;\n\t\n\treturn { aligned, opposite };\n}\n\n// Apply SQL-like pruning rules when both candidates exist, using primeDirection and metricConflictRule\n// to remove one side. Also sets variationIcon to match the remaining candidate(s) and records diagnostics.\n// Notes on global gating and precedence (see engine.ts):\n// - When settings.preferImprovementWhenConflict is true the engine disables favourable trend segmentation\n//   before conflict resolution. That gating happens in engine.ts and ensures improvement-first behaviour\n//   cannot be counteracted by segmentation creating opposite-side trend candidates.\n// - Within pruning, preferTrendWhenConflict is an optional early tie-break that, when enabled, keeps the\n//   side that contains a trend flag and drops the opposite side. It runs only when both candidates exist.\nexport function applySqlPruning(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection,\n\tmetricConflictRule: MetricConflictRule,\n\tpreferImprovementWhenConflict = false,\n\tconflictStrategy?: ConflictStrategy,\n\truleHierarchy?: SpcRuleId[],\n\tpreferTrendWhenConflict = false\n) {\n\t// Get directional summary (also sets row.primeDirection)\n\tconst { up, dn, upMax, dnMax, primeDirection } = getDirectionalSummary(row);\n\trow.primeDirection = primeDirection;\n\tconst originalImprovement = row.specialCauseImprovementValue;\n\tconst originalConcern = row.specialCauseConcernValue;\n\n\t// If both candidates exist, prune one side based on strategy\n\tif (\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tresolveConflict({ row, metric, metricConflictRule, preferImprovementWhenConflict, preferTrendWhenConflict, primeDirection, conflictStrategy, ruleHierarchy });\n\t}\n\n\t// Update variation icon to reflect pruned candidates\n\tif (metric === ImprovementDirection.Up) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernLow\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\n\t// Down metrics\n\t} else if (metric === ImprovementDirection.Down) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementLow\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernHigh\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\t\n\t// Neither metrics\n\t} else {\n\t\t// Neither not used in SQL conflict pruning branch\n\t\trow.variationIcon = VariationIcon.CommonCause;\n\t}\n\n\t// prime rank and winner rule id\n\tconst winningSide =\n\t\trow.specialCauseImprovementValue !== null\n\t\t\t? Side.Up\n\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t? Side.Down\n\t\t\t\t: undefined;\n\tconst winningRank =\n\t\twinningSide === Side.Up\n\t\t\t? upMax\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dnMax\n\t\t\t\t: Math.max(upMax, dnMax);\n\trow.primeRank = winningRank || undefined;\n\tconst winner =\n\t\twinningSide === Side.Up\n\t\t\t? up.find((r) => r.rank === winningRank)\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dn.find((r) => r.rank === winningRank)\n\t\t\t\t: undefined;\n\trow.primeRuleId = winner?.id;\n\n\treturn { originalImprovement, originalConcern };\n}\n\n// General-purpose conflict resolver retaining SQL defaults but enabling alternative strategies.\n// When conflictStrategy is not supplied via settings, we infer it from preferImprovementWhenConflict flag\n// to preserve existing behaviour.\nexport function resolveConflict(args: {\n\trow: SpcRowV2;\n\tmetric: ImprovementDirection;\n\tmetricConflictRule: MetricConflictRule;\n\tpreferImprovementWhenConflict?: boolean;\n\tpreferTrendWhenConflict?: boolean;\n\tprimeDirection?: PrimeDirection;\n\tconflictStrategy?: ConflictStrategy;\n\truleHierarchy?: SpcRuleId[];\n}) {\n\tconst {\n\t\trow,\n\t\tmetric,\n\t\tmetricConflictRule,\n\t\tpreferImprovementWhenConflict,\n\t\tpreferTrendWhenConflict,\n\t\tprimeDirection = row.primeDirection ?? PrimeDirection.Same,\n\t\tconflictStrategy,\n\t\truleHierarchy,\n\t} = args;\n\t// Optional early override: when both candidates exist and a trend flag is present,\n\t// prefer the trend side over non-trend when requested. This runs before other strategies\n\t// to emulate story-specific expectations where a selected trend segment dominates.\n\tif (\n\t\tpreferTrendWhenConflict &&\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tconst upTrend = !!row.trendUp;\n\t\tconst downTrend = !!row.trendDown;\n\t\tif (metric === ImprovementDirection.Up) {\n\t\t\tif (upTrend && !downTrend) {\n\t\t\t\t// Keep improvement (high-side trend), drop concern\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!upTrend && downTrend) {\n\t\t\t\t// Keep concern (low-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\tif (downTrend && !upTrend) {\n\t\t\t\t// Keep improvement (low-side trend), drop concern (high)\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!downTrend && upTrend) {\n\t\t\t\t// Keep concern (high-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Prefer the explicit flag over strategy to mirror the intended Excel-like override.\n\t// If callers want a different behaviour, they should omit the flag and supply a strategy.\n\tconst strategy = preferImprovementWhenConflict\n\t\t? ConflictStrategy.PreferImprovement\n\t\t: conflictStrategy ?? ConflictStrategy.SqlPrimeThenRule;\n\n\tif (strategy === ConflictStrategy.PreferImprovement) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null;\n\t\telse if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t\treturn;\n\t}\n\n\tif (strategy === ConflictStrategy.RuleHierarchy) {\n\t\t// Determine which side contains the highest-precedence rule given an order (defaults to SQL rank)\n\t\tconst order: SpcRuleId[] = ruleHierarchy ?? [SpcRuleId.Trend, SpcRuleId.Shift, SpcRuleId.TwoSigma, SpcRuleId.SinglePoint];\n\t\tconst { up, dn } = getDirectionalSummary(row);\n\t\t// Find first rule in order that appears on either side\n\t\tfor (const rid of order) {\n\t\t\tconst upHas = up.some((r) => r.id === rid);\n\t\t\tconst dnHas = dn.some((r) => r.id === rid);\n\t\t\tif (upHas && !dnHas) {\n\t\t\t\t// keep Up side for Up metrics (improvement) else prune accordingly\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dnHas && !upHas) {\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else row.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upHas && dnHas) {\n\t\t\t\t// Both sides contain same highest rule: fall back to MetricConflictRule\n\t\t\t\tif (metric === ImprovementDirection.Up) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// If nothing matched, default to SQL behaviour\n\t}\n\n\t// Default (SQL parity): PrimeDirection first, then MetricConflictRule only when Same\n\tif (primeDirection === PrimeDirection.Upwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t} else if (primeDirection === PrimeDirection.Downwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseConcernValue = null;\n\t} else {\n\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t}\n}\n\n// Convenience helpers for diagnostics and potential UI integration\n// Compute whether any upward or downward side rules are present on a row\nexport function computeSideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n\tconst upAny = !!(row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp);\n\tconst downAny = !!(row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown);\n\treturn { upAny, downAny };\n}\n\n// True when both sides have at least one active rule (pre- or post-pruning agnostic)\nexport function hasDirectionalConflict(row: SpcRowV2): boolean {\n\tconst { upAny, downAny } = computeSideFlags(row);\n\treturn upAny && downAny;\n}\n", "import {\n\tImprovementDirection,\n\tSpcRowV2,\n\tTrendSegmentationStrategy,\n} from \"../types\";\n\nexport enum TrendDirection { Up = \"Up\", Down = \"Down\" }\nexport enum MeanSide { Above = \"Above\", Below = \"Below\" }\n\nexport interface TrendSegment {\n\ttrendDirection: TrendDirection;\n\tstart: number; // inclusive index in the provided rows array\n\tend: number; // inclusive index\n\tside: MeanSide; // side of mean for all rows in this segment\n\tminValue: number;\n\tmaxValue: number;\n\tmaxAbsDeltaFromMean: number; // max |value-mean| within segment\n}\n\nexport interface TrendRun {\n\ttrendDirection: TrendDirection;\n\tstart: number;\n\tend: number; // inclusive\n\tsegments: TrendSegment[];\n}\n\nfunction signOf(x: number): -1 | 0 | 1 {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n}\n\nfunction sideFor(delta: number): MeanSide | undefined {\n\tconst s = signOf(delta);\n\tif (s > 0) return MeanSide.Above;\n\tif (s < 0) return MeanSide.Below;\n\treturn undefined;\n}\n\n/**\n * Compute contiguous trend runs from backfilled trend flags, and split them into\n * mean-side-consistent segments (Above/Below) across partition mean steps.\n * Points equal to mean are treated as a boundary (not included in either side),\n * so segments will not include rows where value === mean.\n */\nexport function computeTrendSegments(\n\trows: ReadonlyArray<SpcRowV2>\n): TrendRun[] {\n\tconst runs: TrendRun[] = [];\n\n\t// Small helpers to keep the loop readable while preserving control flow\n\tconst startSegment = (\n\t\tk: number,\n\t\tinitialSide: MeanSide,\n\t\tvalue: number\n\t): {\n\t\tsegStart: number;\n\t\tsegSide: MeanSide;\n\t\tminV: number;\n\t\tmaxV: number;\n\t\tmaxAbsDelta: number;\n\t} => ({\n\t\tsegStart: k,\n\t\tsegSide: initialSide,\n\t\tminV: value,\n\t\tmaxV: value,\n\t\tmaxAbsDelta: 0, // caller sets initial delta immediately after\n\t});\n\n\tconst extendSegment = (\n\t\tvalue: number,\n\t\tdeltaAbs: number,\n\t\tminV: number,\n\t\tmaxV: number,\n\t\tmaxAbsDelta: number\n\t): { minV: number; maxV: number; maxAbsDelta: number } => ({\n\t\tminV: Math.min(minV, value),\n\t\tmaxV: Math.max(maxV, value),\n\t\tmaxAbsDelta: Math.max(maxAbsDelta, deltaAbs),\n\t});\n\n\tconst flushSegment = (\n\t\tsegments: TrendSegment[],\n\t\tsegStart: number,\n\t\tendIdx: number,\n\t\tsegSide: MeanSide,\n\t\tminV: number,\n\t\tmaxV: number,\n\t\tmaxAbsDelta: number,\n\t\tdir: TrendDirection\n\t) => {\n\t\tsegments.push({\n\t\t\ttrendDirection: dir,\n\t\t\tstart: segStart,\n\t\t\tend: endIdx,\n\t\t\tside: segSide,\n\t\t\tminValue: minV,\n\t\t\tmaxValue: maxV,\n\t\t\tmaxAbsDeltaFromMean: maxAbsDelta,\n\t\t});\n\t};\n\n\t// Build contiguous runs for trendUp and trendDown separately\n\tlet i = 0;\n\twhile (i < rows.length) {\n\t\tconst r = rows[i];\n\t\tif (!r || r.value == null || r.ghost || (!r.trendUp && !r.trendDown)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst dir: TrendDirection = r.trendUp\n\t\t\t? TrendDirection.Up\n\t\t\t: r.trendDown\n\t\t\t\t? TrendDirection.Down\n\t\t\t\t: (undefined as any);\n\t\t// start of run\n\t\tlet start = i;\n\t\tlet j = i;\n\t\tfor (; j < rows.length; j++) {\n\t\t\tconst rr = rows[j];\n\t\t\tif (!rr || rr.value == null || rr.ghost) break;\n\t\t\tconst sameDir = dir === TrendDirection.Up ? rr.trendUp : rr.trendDown;\n\t\t\tif (!sameDir) break;\n\t\t}\n\t\tconst end = j - 1; // inclusive\n\n\t\t// Segment this run into above/below-mean pieces\n\t\tconst segments: TrendSegment[] = [];\n\t\tlet segStart: number | undefined = undefined;\n\t\tlet segSide: MeanSide | undefined = undefined;\n\t\tlet minV = Infinity,\n\t\t\tmaxV = -Infinity,\n\t\t\tmaxAbsDelta = 0;\n\n\t\tfor (let k = start; k <= end; k++) {\n\t\t\tconst row = rows[k]!;\n\t\t\tif (row.value == null) continue;\n\t\t\tconst delta = row.value - (row.mean ?? 0);\n\t\t\tconst side = sideFor(delta);\n\n\t\t\tif (!side) {\n\t\t\t\t// value equals mean \u2192 boundary: close current seg (if any) and skip this row\n\t\t\t\tif (segStart !== undefined) {\n\t\t\t\t\tflushSegment(segments, segStart, k - 1, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t\t\t\tsegStart = undefined;\n\t\t\t\t\tsegSide = undefined;\n\t\t\t\t\tminV = Infinity;\n\t\t\t\t\tmaxV = -Infinity;\n\t\t\t\t\tmaxAbsDelta = 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (segStart === undefined) {\n\t\t\t\t// start new segment\n\t\t\t\t({ segStart, segSide, minV, maxV, maxAbsDelta } = (() => {\n\t\t\t\t\tconst s = startSegment(k, side, row.value);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsegStart: s.segStart,\n\t\t\t\t\t\tsegSide: s.segSide,\n\t\t\t\t\t\tminV: s.minV,\n\t\t\t\t\t\tmaxV: s.maxV,\n\t\t\t\t\t\tmaxAbsDelta: Math.abs(delta),\n\t\t\t\t\t};\n\t\t\t\t})());\n\t\t\t} else if (side !== segSide) {\n\t\t\t\t// flush previous segment and start new\n\t\t\t\tflushSegment(segments, segStart, k - 1, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t\t\t({ segStart, segSide, minV, maxV, maxAbsDelta } = (() => {\n\t\t\t\t\tconst s = startSegment(k, side, row.value);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsegStart: s.segStart,\n\t\t\t\t\t\tsegSide: s.segSide,\n\t\t\t\t\t\tminV: s.minV,\n\t\t\t\t\t\tmaxV: s.maxV,\n\t\t\t\t\t\tmaxAbsDelta: Math.abs(delta),\n\t\t\t\t\t};\n\t\t\t\t})());\n\t\t\t} else {\n\t\t\t\t// extend\n\t\t\t\tconst updated = extendSegment(row.value, Math.abs(delta), minV, maxV, maxAbsDelta);\n\t\t\t\tminV = updated.minV;\n\t\t\t\tmaxV = updated.maxV;\n\t\t\t\tmaxAbsDelta = updated.maxAbsDelta;\n\t\t\t}\n\t\t}\n\t\tif (segStart !== undefined) {\n\t\t\tflushSegment(segments, segStart, end, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t}\n\n\t\truns.push({ trendDirection: dir, start, end, segments });\n\t\ti = end + 1;\n\t}\n\n\treturn runs;\n}\n\nexport interface SegmentHighlightOptions {\n\tmetricImprovement: ImprovementDirection;\n\tstrategy?: TrendSegmentationStrategy;\n}\n\n/** Map metricImprovement to favourable mean side */\nfunction favourableSide(impr: ImprovementDirection): MeanSide | undefined {\n\tif (impr === ImprovementDirection.Up) return MeanSide.Above;\n\tif (impr === ImprovementDirection.Down) return MeanSide.Below;\n\treturn undefined;\n}\n\nfunction oppositeSide(side: MeanSide | undefined): MeanSide | undefined {\n\tif (!side) return undefined;\n\treturn side === MeanSide.Above ? MeanSide.Below : MeanSide.Above;\n}\n\n/**\n * Choose segments to highlight from a computed run set using a strategy.\n * - FavourableSide: highlight all segments on the favourable side of mean\n * - CrossingAfterFavourable: if a side change occurs, highlight only the first favourable-side\n *   segment after a crossing; otherwise fall back to FavourableSide\n * - ExtremeFavourable: pick the favourable-side segment with the largest |value-mean| extremum\n */\nexport function chooseSegmentsForHighlight(\n\truns: TrendRun[],\n\topts: SegmentHighlightOptions\n): TrendSegment[] {\n\n\tconst strategy = opts.strategy ?? TrendSegmentationStrategy.CrossingAfterFavourable;\n\tconst fav = favourableSide(opts.metricImprovement);\n\tconst unfav = oppositeSide(fav);\n\n\tconst highlight: TrendSegment[] = [];\n\n\tfor (const run of runs) {\n\t\tif (!fav) {\n\t\t\t// Neither: no inherent favourable side; choose the segment with largest absolute distance\n\t\t\tif (\n\t\t\t\tstrategy === TrendSegmentationStrategy.ExtremeFavourable ||\n\t\t\t\tstrategy === TrendSegmentationStrategy.CrossingAfterFavourable\n\t\t\t) {\n\t\t\t\tconst all = run.segments;\n\t\t\t\tif (all.length === 0) continue;\n\t\t\t\tlet best = all[0];\n\t\t\t\tfor (const s of all)\n\t\t\t\t\tif (s.maxAbsDeltaFromMean > best.maxAbsDeltaFromMean) best = s;\n\t\t\t\thighlight.push(best);\n\t\t\t} else {\n\t\t\t\t// FavourableSide in Neither -> nothing by default\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === fav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.UnfavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === unfav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterFavourable) {\n\t\t\t// Detect first segment with fav side that is preceded by a different side\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === fav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== fav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// if run starts already on favourable side and never crosses, fall back later\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\t// fall back: pick the longest favourable segment (by length) if any\n\t\t\t\tconst favSegs = segs.filter((s) => s.side === fav);\n\t\t\t\tif (favSegs.length > 0) {\n\t\t\t\t\tchosen = favSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tfavSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterUnfavourable) {\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === unfav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== unfav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\tconst unSegs = segs.filter((s) => s.side === unfav);\n\t\t\t\tif (unSegs.length > 0) {\n\t\t\t\t\tchosen = unSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tunSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstFavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === fav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstUnfavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === unfav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.end - b.start > a.end - a.start ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.end - b.start > a.end - a.start ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\thighlight.push(favSegs[favSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\thighlight.push(unSegs[unSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn highlight;\n}\n", "import { ImprovementDirection, SpcRowV2, VariationIcon } from \"../types\";\n\n// Engine-level visual categories (UI-agnostic). Keep separate from VariationIcon.\nexport enum SpcVisualCategory {\n\tCommon = \"Common\",\n\tImprovement = \"Improvement\",\n\tConcern = \"Concern\",\n\tNoJudgement = \"NoJudgement\",\n}\n\nexport enum TrendVisualMode {\n  Ungated = \"Ungated\",\n  Gated = \"Gated\",\n}\n\nexport interface VisualCategoryOptions {\n\tmetricImprovement: ImprovementDirection;\n\ttrendVisualMode?: TrendVisualMode; // default Ungated\n\tenableNeutralNoJudgement?: boolean; // default true\n}\n\n// Derive upAny/downAny flags from a row's directional rule flags\nfunction sideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n\tconst upAny = !!(\n\t\trow.singlePointUp ||\n\t\trow.twoSigmaUp ||\n\t\trow.shiftUp ||\n\t\trow.trendUp\n\t);\n\tconst downAny = !!(\n\t\trow.singlePointDown ||\n\t\trow.twoSigmaDown ||\n\t\trow.shiftDown ||\n\t\trow.trendDown\n\t);\n\treturn { upAny, downAny };\n}\n\n/**\n * Compute per-point visual categories from engine rows.\n *\n * Rules\n * - If both upAny and downAny \u2192 Improvement (prefer improvement in conflict)\n * - Else honour engine VariationIcon for improvement/concern\n * - Else when VariationIcon is a Neither* and any special-cause fired:\n *   - Ungated: colour directionally by metricImprovement and side\n *   - Otherwise: NoJudgement when enabled\n * - Else Common\n */\nexport function computeSpcVisualCategories(\n\trows: ReadonlyArray<SpcRowV2>,\n\topts: VisualCategoryOptions\n): SpcVisualCategory[] {\n\tconst metricImprovement = opts.metricImprovement;\n\tconst trendVisualMode: TrendVisualMode = opts.trendVisualMode ?? TrendVisualMode.Ungated;\n\tconst enableNeutral = opts.enableNeutralNoJudgement ?? true;\n\n\treturn rows.map((row) => {\n\t\tif (!row || row.value == null || row.ghost) return SpcVisualCategory.Common;\n\t\tconst { upAny, downAny } = sideFlags(row);\n\n\t\t// Conflict tie-break: prefer Improvement\n\t\tif (upAny && downAny) return SpcVisualCategory.Improvement;\n\n\t\t// Honour engine variation categories first\n\t\tswitch (row.variationIcon) {\n\t\t\tcase VariationIcon.ImprovementHigh:\n\t\t\tcase VariationIcon.ImprovementLow:\n\t\t\t\treturn SpcVisualCategory.Improvement;\n\t\t\tcase VariationIcon.ConcernHigh:\n\t\t\tcase VariationIcon.ConcernLow:\n\t\t\t\treturn SpcVisualCategory.Concern;\n\t\t\tcase VariationIcon.NeitherHigh:\n\t\t\tcase VariationIcon.NeitherLow: {\n\t\t\t\t// Neither metric: treat as neutral special-cause; allow ungated directional colour\n\t\t\t\tif (\n\t\t\t\t\ttrendVisualMode === TrendVisualMode.Ungated &&\n\t\t\t\t\tmetricImprovement !== ImprovementDirection.Neither\n\t\t\t\t) {\n\t\t\t\t\tif (upAny && !downAny) {\n\t\t\t\t\t\treturn metricImprovement === ImprovementDirection.Up\n\t\t\t\t\t\t\t? SpcVisualCategory.Improvement\n\t\t\t\t\t\t\t: SpcVisualCategory.Concern;\n\t\t\t\t\t}\n\t\t\t\t\tif (downAny && !upAny) {\n\t\t\t\t\t\treturn metricImprovement === ImprovementDirection.Down\n\t\t\t\t\t\t\t? SpcVisualCategory.Improvement\n\t\t\t\t\t\t\t: SpcVisualCategory.Concern;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn enableNeutral\n\t\t\t\t\t? SpcVisualCategory.NoJudgement\n\t\t\t\t\t: SpcVisualCategory.Common;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn SpcVisualCategory.Common;\n\t\t}\n\t});\n}\n\nexport default { computeSpcVisualCategories, SpcVisualCategory };\n", "import { ImprovementDirection, SpcRowV2 } from \"../types\";\nimport {\n\tSpcVisualCategory,\n\tcomputeSpcVisualCategories,\n\tTrendVisualMode,\n} from \"./visualCategories\";\n\nexport type BoundaryWindowsMode = \"Disabled\" | \"RecalcCrossing\";\n\nexport interface BoundaryWindowsOptions {\n\tmode?: BoundaryWindowsMode; // default: Disabled\n\tpreWindow?: number; // default: 2 (points immediately before boundary)\n\tpostWindow?: number; // default: 3 (points starting at boundary)\n\t/**\n\t * Controls the polarity of the pre-window category relative to the post-window.\n\t * - \"Opposite\" (default): pre-window uses the opposite category of post-window (contrast around boundary)\n\t * - \"Same\": pre-window uses the same category as post-window (uniform window around boundary)\n\t */\n\tprePolarity?: \"Opposite\" | \"Same\";\n\t/**\n\t * Optional explicit boundary indices to use instead of auto-detecting via partitionId changes.\n\t * Each index should correspond to the first point of a new partition (i.e., the baseline-marked row).\n\t */\n\tboundaryIndices?: number[];\n}\n\n/**\n * Compute visual categories with optional boundary-aware post-classification adjustments.\n *\n * Behaviour (RecalcCrossing):\n * - Detect each partition boundary (partitionId changes).\n * - Compute mean delta: first non-null mean in new partition minus last non-null mean in previous partition.\n * - Determine favourable direction based on metricImprovement (Up -> delta>0, Down -> delta<0).\n * - Apply small windows around the boundary:\n *   - postWindow points [boundary .. boundary+postWindow-1]: set to Improvement if favourable else Concern\n *   - preWindow points [boundary-preWindow .. boundary-1]: set to the opposite category\n * - Never override existing Improvement/Concern categories from base computation; only upgrade\n *   Common/NoJudgement into the window categories.\n * - If metricImprovement === Neither, or either side has no eligible mean, no adjustments are applied for that boundary.\n */\nexport function computeBoundaryWindowCategories(\n\trows: ReadonlyArray<SpcRowV2>,\n\tmetricImprovement: ImprovementDirection,\n\toptions?: BoundaryWindowsOptions\n): SpcVisualCategory[] {\n\tconst mode = options?.mode ?? \"Disabled\";\n\tif (!rows.length) return [];\n\t// Start from base visual categories\n\tlet out = computeSpcVisualCategories(rows, {\n\t\tmetricImprovement,\n\t\ttrendVisualMode: TrendVisualMode.Ungated,\n\t\tenableNeutralNoJudgement: true,\n\t});\n\n\tif (mode !== \"RecalcCrossing\") return out;\n\tif (metricImprovement === ImprovementDirection.Neither) return out;\n\n\tconst preWin = Math.max(0, options?.preWindow ?? 2);\n\tconst postWin = Math.max(0, options?.postWindow ?? 3);\n\tconst prePolarity = options?.prePolarity ?? \"Opposite\";\n\n\t// Helper: safely set category if current is Common/NoJudgement only\n\tconst setIfUpgrade = (idx: number, cat: SpcVisualCategory) => {\n\t\tif (idx < 0 || idx >= out.length) return;\n\t\tconst cur = out[idx];\n\t\tif (\n\t\t\tcur === SpcVisualCategory.Common ||\n\t\t\tcur === SpcVisualCategory.NoJudgement\n\t\t) {\n\t\t\tout[idx] = cat;\n\t\t}\n\t};\n\n\t// Fallback mean when eligibility-gated means are unavailable: average raw values in the partition\n\tconst partitionFallbackMean = (\n\t\tpid: number | string | null\n\t): number | null => {\n\t\tif (pid == null) return null;\n\t\tconst values = rows.reduce<number[]>((acc, r) => {\n\t\t\tif (\n\t\t\t\tr.partitionId === pid &&\n\t\t\t\ttypeof r.value === \"number\" &&\n\t\t\t\t!r.ghost\n\t\t\t) {\n\t\t\t\tacc.push(r.value);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t\tif (!values.length) return null;\n\t\tconst sum = values.reduce((a, b) => a + b, 0);\n\t\treturn sum / values.length;\n\t};\n\n\t// Build list of boundary indices: prefer explicit list, otherwise detect by partitionId changes\n\tconst boundaries: number[] =\n\t\tArray.isArray(options?.boundaryIndices) && options!.boundaryIndices!.length\n\t\t\t? options!.boundaryIndices!.slice().filter((b) => Number.isFinite(b))\n\t\t\t: (() => {\n\t\t\t\treturn rows.reduce<number[]>((acc, cur, i) => {\n\t\t\t\t\tif (i === 0) return acc;\n\t\t\t\t\tconst prev = rows[i - 1];\n\t\t\t\t\tif (prev && cur && cur.partitionId !== prev.partitionId) {\n\t\t\t\t\t\tacc.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn acc;\n\t\t\t\t}, []);\n\t\t\t})();\n\n\tfor (const boundary of boundaries) {\n\t\tconst prev = rows[boundary - 1];\n\t\tconst cur = rows[boundary];\n\t\tif (!prev || !cur) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Determine contiguous segment bounds for the two partitions touching this boundary\n\t\tlet prevStart = boundary - 1;\n\t\twhile (\n\t\t\tprevStart - 1 >= 0 &&\n\t\t\trows[prevStart - 1] &&\n\t\t\trows[prevStart - 1].partitionId === prev.partitionId\n\t\t) {\n\t\t\tprevStart--;\n\t\t}\n\t\tlet curEnd = boundary;\n\t\twhile (\n\t\t\tcurEnd + 1 < rows.length &&\n\t\t\trows[curEnd + 1] &&\n\t\t\trows[curEnd + 1].partitionId === cur.partitionId\n\t\t) {\n\t\t\tcurEnd++;\n\t\t}\n\n\t\t// Find last non-null mean in previous partition\n\t\tlet oldMean: number | null = null;\n\t\tfor (let j = boundary - 1; j >= 0; j--) {\n\t\t\tconst r = rows[j];\n\t\t\tif (r.partitionId !== prev.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\toldMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Find first non-null mean in new partition\n\t\tlet newMean: number | null = null;\n\t\tfor (let k = boundary; k < rows.length; k++) {\n\t\t\tconst r = rows[k];\n\t\t\tif (r.partitionId !== cur.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\tnewMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If eligibility prevented means from materialising on either side, fall back to raw partition averages\n\t\tif (oldMean == null)\n\t\t\toldMean = partitionFallbackMean(prev.partitionId ?? null);\n\t\tif (newMean == null)\n\t\t\tnewMean = partitionFallbackMean(cur.partitionId ?? null);\n\t\tif (oldMean == null || newMean == null) {\n\t\t\t// still insufficient info\n\t\t\tcontinue;\n\t\t}\n\t\tconst delta = newMean - oldMean;\n\t\tconst favourable =\n\t\t\tmetricImprovement === ImprovementDirection.Up ? delta > 0 : delta < 0;\n\t\tconst postCat = favourable\n\t\t\t? SpcVisualCategory.Improvement\n\t\t\t: SpcVisualCategory.Concern;\n\t\tconst preCat =\n\t\t\tprePolarity === \"Same\"\n\t\t\t\t? postCat\n\t\t\t\t: favourable\n\t\t\t\t\t? SpcVisualCategory.Concern\n\t\t\t\t\t: SpcVisualCategory.Improvement;\n\n\t\t// Apply pre-window (clamped to previous partition only)\n\t\tfor (let p = 1; p <= preWin; p++) {\n\t\t\tconst idx = boundary - p;\n\t\t\tif (idx < prevStart) break;\n\t\t\tsetIfUpgrade(idx, preCat);\n\t\t}\n\t\t// Apply post-window (clamped to current partition only)\n\t\tfor (let p = 0; p < postWin; p++) {\n\t\t\tconst idx = boundary + p;\n\t\t\tif (idx > curEnd) break;\n\t\t\tsetIfUpgrade(idx, postCat);\n\t\t}\n\t}\n\n\treturn out;\n}\n\nexport default { computeBoundaryWindowCategories };\n", "import {\n\tSpcSettingsHierarchical,\n\tSpcSettingsInput,\n\tSpcSettingsV26a,\n} from \"./types\";\n\n// Public helper: normalise v2 settings. Accepts flat (v2.6a) or hierarchical input and returns canonical flat settings.\nexport function normaliseSpcSettingsV2(\n\tinput?: SpcSettingsInput\n): SpcSettingsV26a {\n\tif (!input) return {} as SpcSettingsV26a;\n\t// If it looks like flat settings, return as-is\n\tif (\n\t\ttypeof input === \"object\" &&\n\t\t(\"minimumPoints\" in (input as any) ||\n\t\t\t\"shiftPoints\" in (input as any) ||\n\t\t\t\"trendPoints\" in (input as any))\n\t) {\n\t\treturn input as SpcSettingsV26a;\n\t}\n\tconst h = input as SpcSettingsHierarchical;\n\tconst out: SpcSettingsV26a = {};\n\t// thresholds\n\tif (h.thresholds) {\n\t\tconst t = h.thresholds;\n\t\tif (t.minimumPoints != null) out.minimumPoints = t.minimumPoints;\n\t\tif (t.shiftPoints != null) out.shiftPoints = t.shiftPoints;\n\t\tif (t.trendPoints != null) out.trendPoints = t.trendPoints;\n\t\tif (t.excludeMovingRangeOutliers != null)\n\t\t\tout.excludeMovingRangeOutliers = t.excludeMovingRangeOutliers;\n\t}\n\t// eligibility\n\tif (h.eligibility) {\n\t\tif (h.eligibility.chartLevel != null)\n\t\t\tout.chartLevelEligibility = h.eligibility.chartLevel;\n\t}\n\t// parity\n\tif (h.parity) {\n\t\tif (h.parity.trendAcrossPartitions != null)\n\t\t\tout.trendAcrossPartitions = h.parity.trendAcrossPartitions;\n\t\tif (h.parity.twoSigmaIncludeAboveThree != null)\n\t\t\tout.twoSigmaIncludeAboveThree = h.parity.twoSigmaIncludeAboveThree;\n\t\tif (h.parity.enableFourOfFiveRule != null)\n\t\t\tout.enableFourOfFiveRule = h.parity.enableFourOfFiveRule;\n\t}\n\t// conflict\n\tif (h.conflict) {\n\t\tif (h.conflict.preferImprovementWhenConflict != null)\n\t\t\tout.preferImprovementWhenConflict =\n\t\t\t\th.conflict.preferImprovementWhenConflict;\n\t\tif (h.conflict.preferTrendWhenConflict != null)\n\t\t\tout.preferTrendWhenConflict = h.conflict.preferTrendWhenConflict;\n\t\tif (h.conflict.strategy != null) out.conflictStrategy = h.conflict.strategy;\n\t\tif (h.conflict.ruleHierarchy != null)\n\t\t\tout.ruleHierarchy = h.conflict.ruleHierarchy;\n\t\tif (h.conflict.metricRuleOnTie != null)\n\t\t\tout.metricConflictRule = h.conflict.metricRuleOnTie;\n\t}\n\t// trend\n\tif (h.trend?.segmentation) {\n\t\tconst s = h.trend.segmentation;\n\t\tif (s.mode != null) out.trendSegmentationMode = s.mode;\n\t\tif (s.favourableSegmentation != null)\n\t\t\tout.trendFavourableSegmentation = s.favourableSegmentation;\n\t\tif (s.strategy != null) out.trendSegmentationStrategy = s.strategy;\n\t\tif (s.dominatesHighlightedWindow != null)\n\t\t\tout.trendDominatesHighlightedWindow = s.dominatesHighlightedWindow;\n\t}\n\treturn out;\n}\n", "import {\n\tBuildArgsV2,\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\tSpcResultV2,\n\tSpcRowV2,\n\tVariationIcon,\n} from \"./types\";\nimport { computePartitionLimits } from \"./limits\";\nimport { detectRulesInPartition } from \"./detector\";\nimport { applySqlPruning, deriveOriginalCandidates } from \"./conflict\";\nimport { computeTrendSegments, chooseSegmentsForHighlight, TrendDirection } from \"./postprocess/trendSegments\";\nimport { computeSpcVisualCategories, SpcVisualCategory, TrendVisualMode } from \"./postprocess/visualCategories\";\nimport { computeBoundaryWindowCategories, BoundaryWindowsOptions } from \"./postprocess/boundaryWindows\";\nimport { isNumber } from \"./utils\";\nimport { normaliseSpcSettingsV2 } from \"./normaliser\";\n//\n\n// Build an SPC result aligned to SQL v2.6a, focusing on XmR.\n// Mirrors SQL steps but emits per-row icons; dataset parity compares the last non-ghosted row.\nexport function buildSpcV26a(args: BuildArgsV2): SpcResultV2 {\n\tconst { chartType, metricImprovement, data } = args;\n\n\t// There is a legacy flat settings file and a new structured one; normalise to the flat form\n\tconst settings = normaliseSpcSettingsV2(args.settings);\n\n\t// Consolidate with defaults derived from NHSE SQL v2.6a and Making Data Count guidance\n\tconst s = {\n\t\tminimumPoints: 13,\n\t\tshiftPoints: 6,\n\t\ttrendPoints: 6,\n\t\texcludeMovingRangeOutliers: false,\n\t\tmetricConflictRule: MetricConflictRule.Improvement,\n\t\ttrendAcrossPartitions: false,\n\t\ttwoSigmaIncludeAboveThree: false,\n\t\tenableFourOfFiveRule: false,\n\t\tpreferImprovementWhenConflict: false,\n\t\tconflictStrategy: ConflictStrategy.SqlPrimeThenRule,\n\t\truleHierarchy: undefined,\n\t\tchartLevelEligibility: false,\n\t\ttrendFavourableSegmentation: false,\n\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\ttrendSegmentationStrategy: TrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...settings,\n\t};\n\n\t// Resolve legacy boolean to mode if provided explicitly in settings\n\tconst resolvedMode: TrendSegmentationMode =\n\t\tsettings?.trendSegmentationMode ||\n\t\t(settings?.trendFavourableSegmentation === true\n\t\t\t? TrendSegmentationMode.Always\n\t\t\t: settings?.trendFavourableSegmentation === false\n\t\t\t? TrendSegmentationMode.Off\n\t\t\t: s.trendSegmentationMode!);\n\n\t// Canonical rows \u2014 ensure predictable structure and types used throughout the build\n\tconst canon = data.map((d, i) => ({\n\t\trowId: i + 1,\n\t\tx: d.x,\n\t\tvalue: isNumber(d.value) ? d.value! : null,\n\t\tghost: !!d.ghost,\n\t\tbaseline: !!d.baseline,\n\t\ttarget: isNumber(d.target) ? d.target! : null,\n\t}));\n\n\t// Partitioning \u2014 split series at baseline markers (inclusive), calculations occur within these partitions\n\tconst partitions: (typeof canon)[] = [];\n\tlet cur: typeof canon = [];\n\tfor (const r of canon) {\n\t\tif (r.baseline && cur.length) {\n\t\t\tpartitions.push(cur);\n\t\t\tcur = [];\n\t\t}\n\t\tcur.push(r);\n\t}\n\tif (cur.length) partitions.push(cur);\n\n\tconst out: SpcRowV2[] = [];\n\n\t// Global gating for trend segmentation: when preferImprovementWhenConflict is enabled,\n\t// we disable trend segmentation to better match datasets that expect improvement-side dominance\n\t// without segment masking side-effects around the mean crossings.\n\tconst segmentationEnabled =\n\t\t(s.trendFavourableSegmentation || resolvedMode !== TrendSegmentationMode.Off) &&\n\t\t!s.preferImprovementWhenConflict;\n\n\t// Determine chart-level eligibility when enabled: count all non-ghost, valued points across the chart\n\tconst totalEligiblePoints = canon.filter((r) => !r.ghost && isNumber(r.value)).length;\n\tconst chartEligible = !!s.chartLevelEligibility && totalEligiblePoints >= (s.minimumPoints!);\n\tlet partitionId = 0;\n\tfor (const part of partitions) {\n\t\tpartitionId++;\n\t\tconst values = part.map((p) => p.value);\n\t\tconst ghosts = part.map((p) => p.ghost);\n\n\t\t// Eligibility: gate control lines per-row within each partition based on pointRank\n\t\t// A row becomes eligible when there are at least `minimumPoints` non-ghost, valued points in its partition up to and including that row.\n\t\t// This ensures that control lines are only drawn when there is sufficient data.\n\t\tconst lim = computePartitionLimits(\n\t\t\tchartType,\n\t\t\tvalues,\n\t\t\tghosts,\n\t\t\t!!s.excludeMovingRangeOutliers\n\t\t);\n\n\t\t// Build rows with limits and eligibility\n\t\tconst withLines: SpcRowV2[] = part.map((r, i) => {\n\t\t\tconst pointRank =\n\t\t\t\t!r.ghost && isNumber(r.value)\n\t\t\t\t\t? values.slice(0, i + 1).filter((v, j) => !ghosts[j] && isNumber(v)).length\n\t\t\t\t\t: 0;\n\t\t\tconst eligibleHere = chartEligible ? true : pointRank >= (s.minimumPoints!);\n\t\t\treturn {\n\t\t\trowId: r.rowId,\n\t\t\tx: r.x,\n\t\t\tvalue: isNumber(r.value) ? r.value : null,\n\t\t\tghost: r.ghost,\n\t\t\tpartitionId,\n\t\t\tpointRank,\n\t\t\tmean: (eligibleHere || chartEligible) && isNumber(lim.mean) ? lim.mean : null,\n\t\t\tupperProcessLimit: (eligibleHere || chartEligible) ? lim.upperProcessLimit : null,\n\t\t\tlowerProcessLimit: (eligibleHere || chartEligible) ? lim.lowerProcessLimit : null,\n\t\t\tupperTwoSigma: (eligibleHere || chartEligible) ? lim.upperTwoSigma : null,\n\t\t\tlowerTwoSigma: (eligibleHere || chartEligible) ? lim.lowerTwoSigma : null,\n\t\t\tupperOneSigma: (eligibleHere || chartEligible) ? lim.upperOneSigma : null,\n\t\t\tlowerOneSigma: (eligibleHere || chartEligible) ? lim.lowerOneSigma : null,\n\t\t\t// rules\n\t\t\tsinglePointUp: false,\n\t\t\tsinglePointDown: false,\n\t\t\ttwoSigmaUp: false,\n\t\t\ttwoSigmaDown: false,\n\t\t\tfourOfFiveUp: false,\n\t\t\tfourOfFiveDown: false,\n\t\t\tshiftUp: false,\n\t\t\tshiftDown: false,\n\t\t\ttrendUp: false,\n\t\t\ttrendDown: false,\n\t\t\t// candidates\n\t\t\tspecialCauseImprovementValue: null,\n\t\t\tspecialCauseConcernValue: null,\n\t\t\tvariationIcon: VariationIcon.CommonCause,\n\t\t};\n\t\t});\n\n\t\t// Pass 1: single 3-sigma \u2014 mark any point beyond upper/lower process limits\n\t\tfor (const row of withLines) {\n\t\t\tif (\n\t\t\t\trow.ghost ||\n\t\t\t\t!isNumber(row.value) ||\n\t\t\t\trow.mean === null\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (\n\t\t\t\tisNumber(row.upperProcessLimit) &&\n\t\t\t\trow.value! > row.upperProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointUp = true;\n\t\t\tif (\n\t\t\t\tisNumber(row.lowerProcessLimit) &&\n\t\t\t\trow.value! < row.lowerProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointDown = true;\n\t\t}\n\n\t\t// Pass 2: patterns \u2014 shift, two-of-three, strict monotonic trend (per-partition)\n\t\tdetectRulesInPartition(withLines, {\n\t\t\tshiftPoints: s.shiftPoints!,\n\t\t\ttrendPoints: s.trendPoints!,\n\t\t\ttwoSigmaIncludeAboveThree: !!s.twoSigmaIncludeAboveThree,\n\t\t\tenableFourOfFiveRule: !!s.enableFourOfFiveRule,\n\t\t});\n\n\t\t// Optional post-detection step: trend favourable segmentation to resolve cross-mean conflicts\n\t\tconst maybeApplySegmentation = (rows: SpcRowV2[]) => {\n\t\t\t// Determine if this partition has any potential conflicts (both sides active on any row)\n\t\t\tconst hasConflict = rows.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Off ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && !hasConflict)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Apply segmentation to determine favourable trend segments to highlight\n\t\t\t// and use these to mask out trend flags that are not part of a highlighted segment.\n\t\t\t// This ensures that only rules aligned with the favourable trend segments can survive pruning.\n\t\t\t// Note: this does not affect the base rule flags, only whether they can survive pruning.\n\t\t\t// This means that the visual categories (which are computed later) may still show\n\t\t\tconst runs = computeTrendSegments(rows);\n\n\t\t\t// Choose segments to highlight based on the configured strategy\n\t\t\t// (this also filters out short segments that do not meet the trendPoints threshold)\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, {\n\t\t\t\tmetricImprovement,\n\t\t\t\tstrategy: s.trendSegmentationStrategy,\n\t\t\t});\n\n\t\t\t// Build directional allow masks so a row can only retain the trend flag\n\t\t\t// corresponding to the highlighted segment's direction it belongs to.\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === TrendDirection.Up) allowUp.add(k);\n\t\t\t\t\telse allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mask out trend flags that are not part of a highlighted segment\n\t\t\t// (other rule flags are unaffected)\n\t\t\trows.forEach((row, idx) => {\n\t\t\t\t// Recode trend flags to only keep those explicitly allowed by highlighted segments\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\t// Optional: let trend dominate inside highlighted window by clearing opposite-side non-trend flags\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\t// Inside an upward trend segment: drop down-side non-trend rules\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\t// Inside a downward trend segment: drop up-side non-trend rules\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// Apply segmentation if enabled and there is any conflict to resolve\n\t\t// (otherwise segmentation is skipped to avoid unnecessary side-effects)\n\t\tif (segmentationEnabled) {\n\t\t\tmaybeApplySegmentation(withLines);\n\t\t}\n\n\t\t// Candidate formation and pruning for all rows (engine v2.6a parity)\n\t\tfor (const row of withLines) {\n\t\t\t// Skip ghost rows and those without a valid value/mean\n\t\t\t// (these remain as CommonCause with no candidates)\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) {\n\t\t\t\tout.push(row);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Derive original candidates from unpruned rule flags\n\t\t\t// (these are later pruned to yield the final candidates)\n\t\t\t// Note: for Neither metrics, candidates are still derived but not used in pruning\n\t\t\t// as NeitherHigh/NeitherLow icons are determined directly from rule flags.\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(\n\t\t\t\trow,\n\t\t\t\tmetricImprovement\n\t\t\t);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\t\t\t\n\t\t\t\t\tif (metricImprovement === ImprovementDirection.Neither) {\n\t\t\t\t\t\t// Neither semantics: high-side rules -> NeitherHigh, low-side rules -> NeitherLow, else CommonCause\n\t\t\t\t\t\tconst highSide = row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp;\n\t\t\t\t\t\tconst lowSide = row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown;\n\t\t\t\t\t\trow.variationIcon = highSide ? VariationIcon.NeitherHigh : lowSide ? VariationIcon.NeitherLow : VariationIcon.CommonCause;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Up/Down metrics: apply SQL-style pruning and then set icon via pruning outcome\n\t\t\t\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t\t\t\t}\n\t\t\t\n\t\t\tout.push(row);\n\t\t}\n\t}\n\n\t// Optional global trend detection across partitions (SQL v2.2+):\n\tif (s.trendAcrossPartitions) {\n\t\t// Build a flat, ordered index of all non-ghost, valued rows\n\t\tconst all = out.map((r, i) => ({ idx: i, r })).filter(({ r }) => !r.ghost && isNumber(r.value));\n\t\tif (all.length >= s.trendPoints!) {\n\t\t\tfor (let w = 0; w <= all.length - s.trendPoints!; w++) {\n\t\t\t\tconst win = all.slice(w, w + s.trendPoints!).map((p) => p.idx);\n\t\t\t\tconst seq = win.map((i) => out[i]);\n\t\t\t\tif (!seq.every((row) => isNumber(row.value))) continue;\n\t\t\t\tlet inc = true;\n\t\t\t\tlet dec = true;\n\t\t\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\t\t\tif (!inc && !dec) break;\n\t\t\t\t}\n\t\t\t\tif (inc) win.forEach((i) => (out[i].trendUp = true));\n\t\t\t\tif (dec) win.forEach((i) => (out[i].trendDown = true));\n\t\t\t}\n\t\t}\n\t}\n\n\t// If global trend flags were added post hoc, re-apply pruning to stabilise variationIcon with updated rule flags\n\tif (s.trendAcrossPartitions) {\n\t\t// Optional: apply favourable trend segmentation across the whole series\n\t\tif (segmentationEnabled) {\n\t\t\tconst hasConflict = out.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Always ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && hasConflict)\n\t\t\t) {\n\t\t\tconst runs = computeTrendSegments(out);\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, { metricImprovement, strategy: s.trendSegmentationStrategy });\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === TrendDirection.Up) allowUp.add(k); else allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.forEach((row, idx) => {\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor (const row of out) {\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) continue;\n\t\t\tif (metricImprovement === ImprovementDirection.Neither) continue;\n\t\t\t// Recompute candidates from updated flags\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(row, metricImprovement);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\t\t\t// Re-apply pruning to stabilise outcome\n\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t}\n\t}\n\n\treturn { rows: out };\n}\n\nexport default { buildSpcV26a };\n\n// Engine-owned visuals API: compute UI-agnostic visual categories with optional boundary-window upgrades\nexport function buildSpcV26aWithVisuals(\n\targs: BuildArgsV2,\n\tvisuals?: {\n\t\ttrendVisualMode?: TrendVisualMode;\n\t\tenableNeutralNoJudgement?: boolean;\n\t\tboundaryWindows?: (BoundaryWindowsOptions & { directionOverride?: ImprovementDirection });\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst res = buildSpcV26a(args);\n\tconst base = computeSpcVisualCategories(res.rows, {\n\t\tmetricImprovement: args.metricImprovement,\n\t\ttrendVisualMode: visuals?.trendVisualMode ?? TrendVisualMode.Ungated,\n\t\tenableNeutralNoJudgement: visuals?.enableNeutralNoJudgement ?? true,\n\t});\n\n\tconst bw = visuals?.boundaryWindows;\n\tif (!bw || bw.mode !== \"RecalcCrossing\") return { rows: res.rows, visuals: base };\n\n\tconst dir = bw.directionOverride ?? args.metricImprovement;\n\tconst win = computeBoundaryWindowCategories(res.rows, dir, bw);\n\n\t// Overlay upgrade: only promote Common/NoJudgement to Improvement/Concern as per window categories\n\tconst overlay: SpcVisualCategory[] = base.map((cat, i) => {\n\t\tconst w = win[i];\n\t\tif (cat === SpcVisualCategory.Common || cat === SpcVisualCategory.NoJudgement) {\n\t\t\tif (w === SpcVisualCategory.Improvement) return SpcVisualCategory.Improvement;\n\t\t\tif (w === SpcVisualCategory.Concern) return SpcVisualCategory.Concern;\n\t\t}\n\t\treturn cat;\n\t});\n\treturn { rows: res.rows, visuals: overlay };\n}\n\n// Intentionally not re-exporting SpcVisualCategory here; canonical path is via postprocess/visualCategories (barrel re-exports)\n", "import { buildSpcV26aWithVisuals } from \"./engine\";\nimport { SpcVisualCategory, TrendVisualMode } from \"./postprocess/visualCategories\";\nimport {\n\tBuildArgsV2,\n\tImprovementDirection,\n\tSpcRowV2,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\ttype SpcSettingsV26a,\n} from \"./types\";\n\nexport enum VisualsScenario {\n\tNone = \"none\",\n\tRecalcCrossingShift = \"recalc-crossing-shift\",\n\tRecalcCrossingTrend = \"recalc-crossing-trend\",\n\tRecalcCrossingTwoSigma = \"recalc-crossing-two-sigma\",\n\tRecalculationsRecalculated = \"recalculations-recalculated\",\n\tBaselinesRecalculated = \"baselines-recalculated\",\n}\n\nexport function buildVisualsForScenario(\n\targs: BuildArgsV2,\n\tscenario: VisualsScenario,\n\topts?: {\n\t\ttrendVisualMode?: TrendVisualMode;\n\t\tenableNeutralNoJudgement?: boolean;\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst tvm = opts?.trendVisualMode ?? TrendVisualMode.Ungated;\n\tconst enn = opts?.enableNeutralNoJudgement ?? true;\n\n\t// Compute boundary indices from provided baselines first (deterministic in dataset tests)\n\tconst explicitBoundaries: number[] = Array.isArray(args.data)\n\t\t? args.data.map((d, i) => (d?.baseline ? i : -1)).filter((i) => i >= 0)\n\t\t: [];\n\n\tlet boundaryWindows: any | undefined;\n\tswitch (scenario) {\n\t\tcase VisualsScenario.RecalcCrossingShift: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 2,\n\t\t\t\tpostWindow: 4,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTrend: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 5,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTwoSigma: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 1,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.BaselinesRecalculated:\n\t\t\t// postWindow will be extended after build once we know boundary index and series length\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 0,\n\t\t\t\tpostWindow: 0,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: args.metricImprovement,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\tcase VisualsScenario.RecalculationsRecalculated:\n\t\tcase VisualsScenario.None:\n\t\tdefault:\n\t\t\tboundaryWindows = undefined;\n\t}\n\n\tconst { rows, visuals } = buildSpcV26aWithVisuals(args, {\n\t\ttrendVisualMode: tvm,\n\t\tenableNeutralNoJudgement: enn,\n\t\tboundaryWindows,\n\t});\n\n\tlet out = visuals.slice();\n\n\t// Find first boundary index (prefer explicit baselines)\n\tlet boundaryIndex = explicitBoundaries.length ? explicitBoundaries[0]! : -1;\n\tif (boundaryIndex < 0) {\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tif (rows[i].partitionId !== rows[i - 1].partitionId) {\n\t\t\t\tboundaryIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scenario-specific adjustments\n\tif (\n\t\tscenario === VisualsScenario.RecalculationsRecalculated ||\n\t\tscenario === VisualsScenario.BaselinesRecalculated\n\t) {\n\t\tif (boundaryIndex > 0) {\n\t\t\tout[boundaryIndex - 1] = SpcVisualCategory.Common;\n\t\t}\n\t}\n\t// For BaselinesRecalculated, we do not force post-baseline colours here; dataset expectations provide explicit colours.\n\n\treturn { rows, visuals: out };\n}\n\n// ---- Settings presets (engine-owned) ----\n\n// SQL v2.6 parity preset (with trend across partitions from SQL v2.2 note)\nexport const PARITY_V26: Readonly<SpcSettingsV26a> = Object.freeze({\n\tminimumPoints: 13,\n\tshiftPoints: 6,\n\ttrendPoints: 6,\n\texcludeMovingRangeOutliers: false,\n\tmetricConflictRule: MetricConflictRule.Improvement,\n\ttrendAcrossPartitions: true,\n\ttwoSigmaIncludeAboveThree: true,\n\tchartLevelEligibility: true,\n});\n\nexport function withParityV26(overrides?: SpcSettingsV26a): SpcSettingsV26a {\n\treturn { ...PARITY_V26, ...(overrides ?? {}) };\n}\n\n// Conflict-focused preset for datasets with trend/mean crossings.\n// Uses segmentation with CrossingAfterUnfavourable and keeps other parity defaults.\nexport function withConflictPresetV26(\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\treturn withParityV26({\n\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\ttrendSegmentationStrategy:\n\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t// Keep strict SQL pruning semantics by default; allow caller to opt into stronger levers below\n\t\tpreferTrendWhenConflict: false,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...(overrides ?? {}),\n\t});\n}\n\n// Direction-aware conflict preset that auto-chooses the safest behaviour per improvement direction:\n//  - Up (\"High is good\"): prefer improvement override and implicitly disable segmentation via engine gating\n//  - Down (\"Low is good\"): keep segmentation enabled with CrossingAfterUnfavourable (works for dataset parity)\n//  - Neither: fall back to generic conflict preset defaults\n// Overrides are applied last so callers (e.g. Storybook controls) can still force a specific behaviour.\nexport function withConflictPresetAutoV26(\n\tmetricImprovement: ImprovementDirection,\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\tswitch (metricImprovement) {\n\t\tcase ImprovementDirection.Up:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Engine will gate segmentation off when this is true\n\t\t\t\tpreferImprovementWhenConflict: true,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tcase ImprovementDirection.Down:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Keep segmentation to resolve cross-mean runs for low-is-good datasets\n\t\t\t\tpreferImprovementWhenConflict: false,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\t\t\ttrendSegmentationStrategy:\n\t\t\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tdefault:\n\t\t\treturn withConflictPresetV26({ ...(overrides ?? {}) });\n\t}\n}\n// Named exports only; no default export to avoid collisions\n", "import { ImprovementDirection, SpcRowV2, VariationIcon, Side } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface RetroOverlayOptions {\n\t// Currently we only support retro-colouring for confirmed shift runs.\n\t// Two-of-three and single >3\u03C3 are intentionally not backfilled to keep\n\t// alignment with NHSE SQL semantics for per-row eligibility.\n\tenableShift?: boolean;\n}\n\nfunction iconFor(side: Side, dir: ImprovementDirection): VariationIcon {\n\tif (dir === ImprovementDirection.Neither) {\n\t\treturn side === Side.Up ? VariationIcon.NeitherHigh : VariationIcon.NeitherLow;\n\t}\n\tif (dir === ImprovementDirection.Up) {\n\t\treturn side === Side.Up\n\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t: VariationIcon.ConcernLow;\n\t}\n\t// dir === Down\n\treturn side === Side.Up\n\t\t? VariationIcon.ConcernHigh\n\t\t: VariationIcon.ImprovementLow;\n}\n\n/**\n * Compute a \"teaching view\" overlay that retro-colours pre-eligibility points\n * that sit on the same side of the mean as a later confirmed shift run.\n *\n * Notes and constraints (to preserve SQL parity):\n * - Engine rows remain unchanged; callers should only use these icons for\n *   visuals. The default engine `variationIcon` is still the source of truth\n *   for parity and testing.\n * - Only shift runs are backfilled; single-point and two-of-three are not\n *   retro-coloured.\n * - Backfill stops at the first eligible row in the partition; we never paint\n *   into rows where the engine would not have had limits yet.\n */\nexport function computeRetroShiftOverlay(\n\trows: SpcRowV2[],\n\tmetricImprovement: ImprovementDirection,\n\topts?: RetroOverlayOptions\n): Array<VariationIcon | null> {\n\tconst { enableShift = true } = opts ?? {};\n\tconst overlay: Array<VariationIcon | null> = Array(rows.length).fill(null);\n\tif (!enableShift) return overlay;\n\n\t// Group indices by partition\n\tconst byPart = new Map<number, number[]>();\n\trows.forEach((r, i) => {\n\t\tif (!byPart.has(r.partitionId)) byPart.set(r.partitionId, []);\n\t\tbyPart.get(r.partitionId)!.push(i);\n\t});\n\n\tfor (const [, idxs] of byPart) {\n\t\t// Identify the first eligible index in this partition\n\t\tconst firstEligibleIdx = idxs.find((i) => isNumber(rows[i].mean));\n\t\tif (firstEligibleIdx == null) continue;\n\n\t// Walk through eligible rows to find contiguous shift runs; for each run,\n\t// extend backwards across pre-eligibility rows that lie on the same side of\n\t// the mean at the run's start.\n\tlet runStart: number | null = null;\n\tlet runSide: Side | null = null;\n\n\tconst commitRun = (startIdx: number, side: Side) => {\n\t\t\t// Use the mean at startIdx as the reference; walk backwards to just before\n\t\t\t// the first eligible index, colouring points that lie on the same side.\n\t\t\tconst refMean = rows[startIdx].mean!;\n\t\t\tfor (let j = startIdx - 1; j >= idxs[0]; j--) {\n\t\t\t\tconst r = rows[j];\n\t\t\t\tif (r.ghost || !isNumber(r.value)) continue;\n\t\t\t\tif (j >= firstEligibleIdx) break; // never paint into eligible region\n\t\t\t\tconst sameSide = side === Side.Up ? r.value! > refMean : r.value! < refMean;\n\t\t\t\tif (!sameSide) break; // stop when side breaks\n\t\t\t\toverlay[j] = iconFor(side, metricImprovement);\n\t\t\t}\n\t\t};\n\n\t\tfor (const i of idxs) {\n\t\t\tconst r = rows[i];\n\t\t\tconst eligible = isNumber(r.mean);\n\t\t\tif (!eligible) {\n\t\t\t\t// only scan shift runs where engine was eligible\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst up = !!r.shiftUp;\n\t\t\tconst down = !!r.shiftDown;\n\t\t\tconst side: Side | null = up ? Side.Up : down ? Side.Down : null;\n\n\t\t\tif (side) {\n\t\t\t\t// If we are starting or continuing a run, manage state\n\t\t\t\tif (runStart == null) {\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t} else if (runSide === side) {\n\t\t\t\t\t// continuing same-side run \u2014 nothing else to do yet\n\t\t\t\t} else {\n\t\t\t\t\t// side flipped \u2014 commit previous run and start new\n\t\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t}\n\t\t\t} else if (runStart != null) {\n\t\t\t\t// run ended; commit and reset\n\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\trunStart = null;\n\t\t\t\trunSide = null;\n\t\t\t}\n\t\t}\n\n\t\t// Commit trailing run if still open\n\t\tif (runStart != null && runSide != null) commitRun(runStart, runSide);\n\t}\n\n\treturn overlay;\n}\n\nexport default { computeRetroShiftOverlay };\n"],
  "mappings": "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",
  "names": ["ChartType", "ImprovementDirection", "VariationIcon", "Side", "SpcWarningSeverity", "SpcWarningCategory", "SpcWarningCode", "mr", "mean", "SpcVisualCategory", "TrendVisualMode", "VisualsScenario"]
}
