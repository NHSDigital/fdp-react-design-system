#!/usr/bin/env node
/**
 * Sync SPC source files from monorepo canonical locations into the internal package
 * packages/nhs-fdp-spc/src so the package can build independently (for subtree split/publish).
 *
 * Single Source of Truth: the canonical files live under src/components/DataVisualisation/**.
 * These copies are generated â€“ do not edit the vendored files inside packages/nhs-fdp-spc/src.
 */
const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..');
const pkgRoot = path.resolve(root, 'packages/nhs-fdp-spc');
const srcRoot = path.resolve(root, 'src');
const pkgSrc = path.resolve(pkgRoot, 'src');

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function copyFile(from, to, opts = {}) {
  ensureDir(path.dirname(to));
  let content = fs.readFileSync(from, 'utf8');
  if (opts.header) {
    const header = opts.header.replace(/\n?$/, '\n');
    // Insert header only if not already present
    if (!content.startsWith(header)) content = header + content;
  }
  if (typeof opts.transform === 'function') {
    content = opts.transform(content, from, to);
  }
  fs.writeFileSync(to, content);
}

function copyDir(fromDir, toDir, { filter } = {}) {
  const entries = fs.readdirSync(fromDir, { withFileTypes: true });
  for (const ent of entries) {
    const from = path.join(fromDir, ent.name);
    const to = path.join(toDir, ent.name);
    if (filter && !filter(from, ent)) continue;
    if (ent.isDirectory()) {
      copyDir(from, to, { filter });
    } else if (ent.isFile()) {
      copyFile(from, to, { header: GENERATED_HEADER });
    }
  }
}

const GENERATED_HEADER = `/**
 * GENERATED FILE (do not edit)
 * Source of truth: src/components/DataVisualisation/** in nhs-fdp-design-system monorepo.
 * Generated by scripts/spc-sync-sources.cjs
 */\n`;

// Map of canonical -> package destination (directories)
const dirCopies = [
  ['components/DataVisualisation/charts/SPC', 'components/DataVisualisation/charts/SPC'],
  ['components/DataVisualisation/core', 'components/DataVisualisation/core'],
  ['components/DataVisualisation/hooks', 'components/DataVisualisation/hooks'],
  ['components/DataVisualisation/charts/Axis', 'components/DataVisualisation/charts/Axis'],
  ['components/DataVisualisation/charts/GridLines', 'components/DataVisualisation/charts/GridLines'],
  ['components/DataVisualisation/utils', 'components/DataVisualisation/utils'],
  // UI primitives used by SPC tooltip overlay
  ['components/Tag', 'components/Tag'],
  // Diagnostics panel tables dependency
  ['components/Tables', 'components/Tables'],
  ['components/Panel', 'components/Panel'],
  ['components/Heading', 'components/Heading'],
];

// Single-file copies
const fileCopies = [
  ['components/DataVisualisation/series/LineSeriesPrimitive.tsx', 'components/DataVisualisation/series/LineSeriesPrimitive.tsx'],
  ['components/DataVisualisation/primitives/VisuallyHiddenLiveRegion.tsx', 'components/DataVisualisation/primitives/VisuallyHiddenLiveRegion.tsx'],
  ['components/DataVisualisation/DataVisualisation.scss', 'components/DataVisualisation/DataVisualisation.scss'],
  // Mapping used by Tag component
  ['mapping/tag.ts', 'mapping/tag.ts'],
];

// Token JSONs required by colors utilities
const tokenCopies = [
  ['packages/nhs-fdp/tokens/data-viz.json', 'tokens/data-viz.json'],
  ['packages/nhs-fdp/tokens/colors.json', 'tokens/colors.json']
];

function exists(p) { return fs.existsSync(p); }

function main() {
  // Validate roots
  if (!exists(srcRoot)) {
    console.error('[spc-sync] Cannot find src/ at', srcRoot);
    process.exit(1);
  }
  if (!exists(pkgSrc)) {
    console.error('[spc-sync] Cannot find package src/ at', pkgSrc);
    process.exit(1);
  }

  // Copy directories
  for (const [fromRel, toRel] of dirCopies) {
    const from = path.join(srcRoot, fromRel);
    const to = path.join(pkgSrc, toRel);
    if (!exists(from)) {
      console.warn(`[spc-sync] Skip missing dir: ${fromRel}`);
      continue;
    }
    console.log(`[spc-sync] Dir: ${fromRel} -> packages/nhs-fdp-spc/src/${toRel}`);
    copyDir(from, to, {
      filter: (p, ent) => !/\.(stories|client\.test|ssr\.test|hydration\.test|a11y\.test)\.(tsx|ts)$/.test(p)
    });
  }

  // Copy single files
  for (const [fromRel, toRel] of fileCopies) {
    const from = path.join(srcRoot, fromRel);
    const to = path.join(pkgSrc, toRel);
    if (!exists(from)) {
      console.warn(`[spc-sync] Skip missing file: ${fromRel}`);
      continue;
    }
    console.log(`[spc-sync] File: ${fromRel} -> packages/nhs-fdp-spc/src/${toRel}`);
    copyFile(from, to, { header: GENERATED_HEADER });
  }

  // Copy tokens JSONs
  for (const [fromRel, toRel] of tokenCopies) {
    const from = path.join(root, fromRel);
    const to = path.join(pkgSrc, toRel);
    if (!exists(from)) {
      console.warn(`[spc-sync] Skip missing token: ${fromRel}`);
      continue;
    }
    console.log(`[spc-sync] Token: ${fromRel} -> packages/nhs-fdp-spc/src/${toRel}`);
    ensureDir(path.dirname(to));
    fs.copyFileSync(from, to);
  }

  // Post-process colors.ts to point to vendored tokens
  const colorsSrc = path.join(pkgSrc, 'components/DataVisualisation/utils/colors.ts');
  if (exists(colorsSrc)) {
    console.log('[spc-sync] Patch utils/colors.ts token imports');
    const original = fs.readFileSync(colorsSrc, 'utf8');
    const patched = original
      .replace(/\.\.\/\.\.\/\.\.\/packages\/nhs-fdp\/tokens\/data-viz\.json/g, '../../../tokens/data-viz.json')
      .replace(/\.\.\/\.\.\/\.\.\/packages\/nhs-fdp\/tokens\/colors\.json/g, '../../../tokens/colors.json');
    fs.writeFileSync(colorsSrc, patched);
  }

  console.log('[spc-sync] Done. (Generated files are marked with headers)');
}

main();
