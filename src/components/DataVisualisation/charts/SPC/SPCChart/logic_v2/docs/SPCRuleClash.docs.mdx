import { Meta } from '@storybook/addon-docs/blocks';
import {
	RuleClashChart1Trend,
	RuleClashChart2Shift,
	RuleClashChart3TwoOfThree,
	RuleClashChart4SinglePoint,
	RuleClashChart5MultipleRules,
} from "./SPCRuleClash.examples";

<Meta title="Data Visualisation/SPC/Guides/Rule Clash Guidance" />

# SPC Rule Clash Guidance

This guide shows how v2 resolves situations where multiple special‑cause rules plausibly fire on related subsets of data (“rule clash”). It clarifies expected precedence and interpretation when simultaneous patterns (e.g. emerging shift plus single outlier) occur.

These are synthetic sequences analogous to the legacy reference imagery. Each example is an Individuals (XmR) chart using v2 with SQL parity settings (chart‑level eligibility, backfill, two‑of‑three includes ≥3σ). Data are monthly points rendered via `SPCChart`.

## Rule Clash Chart 1 — Trend (monotonic run, default N = 6)

<RuleClashChart1Trend />

**Commentary**: Gradual monotonic increase with a brief dip that breaks a potential shift. The trend rule (default N = 6) should trigger; shift resets at the dip. With chart‑level eligibility, once the trend confirms, the full run is backfilled. No single‑point outlier is expected in this sequence.

## Rule Clash Chart 2 — Shift (run one side of mean, default N = 6)

<RuleClashChart2Shift />

**Commentary**: A sustained run below the mean meets the shift threshold. With lower‑is‑better (Down), this is an Improvement. Isolated outliers are not expected here; if any near‑limit clusters occur, the confirmed shift dominates in precedence.

## Rule Clash Chart 3 — Two‑of‑three ≥ 2σ (same side)

<RuleClashChart3TwoOfThree />

**Commentary**: After a stable baseline, a low‑side cluster meets two‑of‑three (≥ 2σ, counting ≥ 3σ in parity). The sequence then settles into a lower band that can reach a confirmed shift below the mean. Precedence: once the shift confirms, it dominates; earlier two‑of‑three windows may remain backfilled but lose in conflict pruning.

## Rule Clash Chart 4 — Single point beyond 3σ

<RuleClashChart4SinglePoint />

**Commentary**: A single high outlier appears amid an otherwise stable baseline. Only that point should be coloured; no sustained rules are expected. Subsequent points return to Common Cause.

## Multiple rules example — Outlier → shift → opposing trend

<RuleClashChart5MultipleRules />

**Commentary**: The series shows (1) an early high outlier, (2) an improvement shift (plateau above the mean), and (3) a later downward trend (unfavourable for higher‑is‑better metrics). v2 conflict pruning ensures the most recent sustained rule (the downward trend) governs the end‑state classification.

## Precedence & Messaging

When multiple rules trigger on overlapping windows, messaging should:

1. Prefer sustained rules (trend, shift) over isolated single‑point outliers.
2. Recognise that two‑of‑three often precedes a shift; once shift confirms, it takes precedence.
3. Resolve conflicts via v2 pruning (PrimeDirection and rule ranking: Trend > Shift > TwoSigma > SinglePoint), emphasising the most recent sustained pattern.

Note: The optional four‑of‑five (≥ 1σ) rule is excluded from primary ranking in v2 and should be treated as an early‑warning signal rather than a determinant in conflicts.

| Scenario | Example | Preferred Narrative | Secondary Signals (Suppressed) |
|----------|---------|---------------------|--------------------------------|
| Single high outlier after stable run | Chart 4 | "Special cause (single point >3σ)" | — |
| Cluster evolving into shift | Chart 3 | "Shift to lower level (two‑of‑three preceded)" | Early two‑of‑three cluster |
| Outlier → shift → opposing trend | Chart 5 | "Most recent sustained rule dominates (downward trend)" | Earlier outlier and shift |

## Backfill semantics (SQL parity)

The SQL logic evaluates special‑cause rules once the chart qualifies as an SPC chart, and then backfills detected patterns across the full qualifying window/run, including early rows. Our v2 engine now follows this semantics in parity mode.

- Eligibility gating (chart‑level) first
	- A chart is considered eligible once it has at least the minimum number of non‑ghosted points overall (XmR default: 13). When eligible, means/limits exist for all rows in each partition, and rules are evaluated across the full partition, allowing early windows to be coloured.
	- Outside parity mode, a stricter “per‑point” eligibility can be used where limits appear only once each point passes the threshold; this avoids retro‑colouring early rows.

- Single point >3σ
	- Marks that single row only; no backfill beyond the outlier itself.

- Two‑of‑three ≥2σ (same side)
	- When any 3‑point window contains at least two points at or beyond 2σ on the same side of the mean (including ≥3σ), all three rows in that window are marked. Overlapping windows are allowed; later pruning resolves conflicts so only the winning candidate remains per row.

- Shift (6) on one side of the mean
	- Once a contiguous run of eligible points on the same side reaches the threshold, the entire run is backfilled (not just the triggering point). The run resets if a point crosses the mean or at any row where mean/limits are null (gaps, pre‑eligibility).

- Trend (6) strictly increasing/decreasing
	- Analogous to shift: when the strictly monotonic run reaches the threshold, backfill the whole run. Resets at any non‑monotonic step or at rows without mean/limits. Optional cross‑partition trend can be enabled; it still requires eligibility on both sides and never crosses gaps lacking limits.

- Conflict resolution after detection
	- Rules produce candidates which may overlap. A deterministic pruning step applies precedence (including prime direction and rule priorities) so each row ends with at most one icon. Backfilled marks from losing candidates are cleared; rows not in any surviving candidate and within limits are shown as “Neither/Common cause”.

Note: This approach ensures the chart only paints signals from the point in time where there was enough history to detect them. Early points can remain Common Cause even if later a shift/trend emerges.

## Summary

These examples aid design of consistent precedence logic so users see a concise, meaningful summary instead of a confusing cluster of rule labels.
