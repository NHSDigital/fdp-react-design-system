import { Meta, Canvas, Story } from '@storybook/addon-docs/blocks';
import Table from '../../../../Tables/Table';

<Meta title="Data Visualisation/SPC/SPC Precedence & Directional Strategy"/>

## SPC Precedence & Directional Strategy

### Background

Legacy variation classification picked the icon per row using a simple side-based rule aggregation:

```ts
import { ImprovementDirection, VariationIcon } from './logic/spc';

// Legacy side aggregation (conceptual)
const anyHigh = singlePointHigh || twoOfThreeHigh || fourOfFiveHigh || shiftHigh || (trendIncreasing && currentPointAboveMean);
const anyLow  = singlePointLow  || twoOfThreeLow  || fourOfFiveLow  || shiftLow  || (trendDecreasing && currentPointBelowMean);

function classify(metricImprovement: ImprovementDirection): VariationIcon {
  if (metricImprovement === ImprovementDirection.Down) {
    return anyLow ? VariationIcon.Improvement : anyHigh ? VariationIcon.Concern : VariationIcon.Neither;
  }
  if (metricImprovement === ImprovementDirection.Up) {
    return anyHigh ? VariationIcon.Improvement : anyLow ? VariationIcon.Concern : VariationIcon.Neither;
  }
  return VariationIcon.Neither; // ImprovementDirection.Neither
}
```

This produced unintuitive colouring in transitional phases – e.g. a *progressive decline* (favourable for metrics where lower is better) still coloured several points as Concern because high-side location-based rules (shift/cluster) remained active before a formal monotonic trend rule triggered.

### Relationship to SQL Compatibility Wrapper

An experimental SQL compatibility wrapper (`buildSpcSqlCompat`) now exists to emulate historic SQL post‑processing (per‑side rule ranking and directional pruning). It leaves the core engine logic (including `precedenceStrategy`) unchanged and applies ranking afterwards, emitting additional metadata for parity / diagnostics (`primeDirection`, `primeRuleId`, `primeRank`, `sqlOriginalImprovementValue`, `sqlOriginalConcernValue`, `sqlPruned`).

Key distinctions:

| Layer | Purpose | Inputs influencing it | Outputs |
|-------|---------|-----------------------|---------|
| Engine + `precedenceStrategy` | Primary statistical interpretation & user-facing icon selection | `SpcSettings` (incl. `precedenceStrategy`, grace flags) | `variationIcon`, rule booleans, `ruleTags` |
| SQL Wrapper (`buildSpcSqlCompat`) | Legacy directional pruning parity & audit | Base engine rows (conflict mode suppressed) | Above plus SQL metadata (prime* fields) |

Use the wrapper only when migration / reconciliation against legacy SQL outputs is required; for day‑to‑day narrative choose the appropriate engine `precedenceStrategy`.

### Guidance Considered

New behaviour aligns with internal guidance:

1. Prioritise directionally consistent sustained rules (shift, long run) over single-point outliers.
2. Collapse redundant signals (e.g. both 2-of-3 and 4-of-5 on same side) into the strongest narrative.
3. Surface conflicting direction signals only if overlapping windows are partial and recency differs; emphasise the most recent sustained direction.

### New Settings (Opt‑In)

Added to `SpcSettings` (defaults preserve legacy behaviour). The string union has been replaced by the `PrecedenceStrategy` enum for stronger typing:

```ts
export enum PrecedenceStrategy {
  Legacy = 'legacy',
  DirectionalFirst = 'directional_first',
}
```

<Table 
  caption="SPC precedence & directional settings"
  captionSize="m"
  firstCellIsHeader
  head={[
    { text: 'Setting' },
    { text: 'Purpose' },
    { text: 'Type' },
    { text: 'Default' },
  ]}
  rows={[
    [
      { code: 'precedenceStrategy' },
      { text: 'Select precedence algorithm' },
      { text: 'PrecedenceStrategy (Legacy / DirectionalFirst)' },
      { code: 'Legacy' },
    ],
    [
      { code: 'emergingDirectionGrace' },
      { text: 'Allows near-complete (N-1) favourable run to neutralise unfavourable classification early' },
      { code: 'boolean' },
      { code: 'false' },
    ],
    [
      { code: 'transitionBufferPoints' },
      { text: 'Grace buffer before flipping when opposing sustained signals compete' },
      { code: 'number' },
      { code: '2' },
    ],
    [
      { code: 'collapseClusterRules' },
      { text: 'Removes weaker cluster rule (2-of-3) when 4-of-5 also fires on same side' },
      { code: 'boolean' },
      { code: 'true' },
    ],
  ]}
/>

### Directional First Algorithm (Simplified)

For each row (after standard rule detection):

1. Derive boolean `favourable` / `unfavourable` sets (side depends on metric polarity).
2. Compute `emergingFavourable` if last (trendN - 1) points are *almost* monotonically moving in favourable direction (allow ≤1 counter step).
3. Apply precedence:
   - Favourable only -> Improvement.
   - Unfavourable only -> Concern (unless `emergingDirectionGrace` & `emergingFavourable` -> downgrade to Neither).
   - Both -> Improvement if emerging or confirmed trend present and grace active, else Neither.
   - Neither -> Neither.
4. (Cluster collapse) If both 2-of-3 and 4-of-5 present same side keep only 4-of-5 flag.

### Outcomes

| Scenario | Legacy | Directional First (grace) |
|----------|--------|---------------------------|
| Progressive decline above mean (lower better) | Early points = Concern | Early points downgraded to Neither until trend confirmed then Improvement |
| Strong high-side shift with no directional change | Concern | Concern (unchanged) |
| Emerging improvement with minor noise | Often Concern until full trend | Earlier neutral / faster Improvement |

### Rationale

The directional-first approach reduces “false negative” perception where users see improving movement but chart signals deterioration. It maintains statistical discipline (full rule still required for definitive Improvement) while communicating transition more faithfully.

### Migration Guidance

1. Enable per chart via:

```tsx
<SPCChart settings={{ precedenceStrategy: PrecedenceStrategy.DirectionalFirst, emergingDirectionGrace: true }} />
```

1. Validate narrative & colour alignment on representative metrics (improvement vs deterioration examples).

1. Optionally display a legend / footnote indicating precedence mode if mixed strategies are deployed across dashboards.

### Future Enhancements (Not Yet Implemented)


### Terminology & Enum Consolidation

Recent refactors replaced loosely typed literals with shared enums:

- Directional side strings `"high" / "low"` → `Side.Up` / `Side.Down`.
- Rule id union → `SpcRuleId` (`single_point`, `two_sigma`, `shift`, `trend`).
- Raw granular audit tags → `SpcRawRuleTag` (e.g. `single_above`, `trend_inc`, `fifteen_inner_third`).

Ranking numbers (Trend 4 > Shift 3 > TwoSigma 2 > SinglePoint 1) are centralised in `RULE_RANK_BY_ID` so both the engine precedence logic and SQL wrapper stay aligned—no duplicated numeric literals.

Benefits:
- Stronger type safety & easier future rule insertion.
- Unified side semantics across engine, wrapper, tooltip logic.
- Clear separation: raw event tags vs consolidated precedence decision.

### Testing Additions

New tests (see `spc.precedence.logic.test.ts`) assert:

1. Declining favourable sequence classification difference legacy vs directional.
2. Cluster collapse (2-of-3 removed when 4-of-5 present) with toggle.

### Opt-Out

Remain on `precedenceStrategy: PrecedenceStrategy.Legacy` for unchanged historical behaviour while evaluating impact.

- Extended SQL parity (optional inclusion of ancillary rules like Fifteen-in-Inner-Third in ranking if legacy procedures evolve).
- Harmonised conflict pathway ensuring wrapper never silently reclassifies an outcome conflicting with engine precedence (future alignment task).
