import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Data Visualisation/SPC/SPC Test Coverage" />

# SPC Engine Test Coverage

This document maps the Statistical Process Control (SPC) engine behaviours to the implemented automated test suites. It provides:

* Rule / behaviour description (aligned to Making Data Count guidance where applicable)
* File & test names
* Purpose & key assertions
* Embedded distilled code examples (trimmed for clarity)
* Notes on edge cases / rationale

> All examples use the XmR chart type unless explicitly stated. Improvement direction affects interpretation of signals (Up metrics treat high-side signals as favourable; Down metrics invert).

---

## 1. Trend Gating (Prevent premature favourable classification)

**Goal:** Ensure increasing/decreasing trends only contribute to Improvement / Concern once the current point is on the favourable side of the mean.

**Tests:**

| File | Tests |
| ---- | ----- |
| `spc.trendSideGate.client.test.ts` | Up, Down, Neutral directional gating |
| `spc.trendEdgeCases.client.test.ts` | Trend entirely adverse-side; crossing mean resets |
| `spc.trendCrossMeanEdge.client.test.ts` | Equal-to-mean interruptions; cross-mean gating |
| `spc.trendAlternatingMixed.client.test.ts` | Alternating equal / above patterns; mixed partial sequences |
| `spc.mixedPrecedence.client.test.ts` | Integrated scenario verifying gating inside multi-signal context |

**Embedded Example (excerpt – side gating):**

```ts
const { rows } = buildSpc({ chartType: ChartType.XmR, metricImprovement: Up, data });
// Below-mean strictly increasing series -> trendIncreasing true
// Gating assertion: no Improvement icon while still below mean
expect(window.every(r => r.specialCauseTrendIncreasing)).toBe(true);
expect(window.some(r => r.variationIcon === VariationIcon.Improvement)).toBe(false);
```

**Rationale:** Prevents early “emerging” trends on the wrong side of the mean from being misclassified as Improvement/Concern.

---

## 2. Two-of-Three Rule (Exclude >3σ Points)

**Change:** Points beyond 3σ (process limits) are excluded from the 2-of-3 (between 2σ & 3σ) cluster count, aligning with MDC guidance to avoid double counting extreme outliers.

**Tests:**

| File | Tests |
| ---- | ----- |
| `spc.twoOfThreeExclusion.client.test.ts` | High-side mid-band pair + >3σ exclusion; insufficient mid-band scenario |
| `spc.twoOfThreeExclusion.lowSide.client.test.ts` | Symmetric low-side mid-band pair + < -3σ exclusion; insufficient case |
| `spc.mixedPrecedence.client.test.ts` | Ensures collapsed cluster ignores redundant 2-of-3 when 4-of-5 present |

**Embedded Example (high-side exclusion):**
```ts
// mid1, mid2 in (2σ, 3σ); extreme > 3σ
expect(midBand.length).toBe(2);
expect(midBand.every(r => r.specialCauseTwoOfThreeAbove)).toBe(true);
expect(extremePt.specialCauseSinglePointAbove).toBe(true);
expect(extremePt.specialCauseTwoOfThreeAbove).toBe(false);
```

**Embedded Example (low-side symmetry):**
```ts
expect(midBand.every(r => r.specialCauseTwoOfThreeBelow)).toBe(true);
expect(extreme.specialCauseSinglePointBelow).toBe(true);
```

---

## 3. Four-of-Five Rule & Cluster Collapse

**Behaviours:**
* Four-of-five beyond ±1σ flagged when all 5 points on same side of mean.
* Optional `collapseClusterRules` removes overlapping 2-of-3 flags when 4-of-5 is stronger, reducing duplicate signalling noise.

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.fourOfFiveSymmetry.client.test.ts` | High & low side activation; low-side collapse interaction |
| `spc.mixedPrecedence.client.test.ts` | High cluster with collapse verifying removal of 2-of-3 |
| `spc.ruleTags.persistence.client.test.ts` | ruleTags retain provenance of both rules after collapse |

**Embedded Example (collapse verification):**
```ts
const overlapCleared = clusterRows
  .filter(r => r.specialCauseFourOfFiveAbove)
  .every(r => !r.specialCauseTwoOfThreeAbove);
expect(overlapCleared).toBe(true);
```

**Embedded Example (ruleTags provenance):**
```ts
expect(after.specialCauseTwoOfThreeAbove).toBe(false); // collapsed
expect(after.ruleTags).toContain('two_of_three_high');  // provenance retained
expect(after.ruleTags).toContain('four_of_five_high');
```

---

## 4. Shift Detection & Auto Baseline Recalculation

**Behaviour:** Automatic insertion of a synthetic baseline flag after a sustained favourable shift (configurable length & delta-sigma).

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.recalcCrossingBoundary.client.test.ts` | Partition boundary change & mean update (delta-sigma threshold) |
| `spc.mixedPrecedence.client.test.ts` | Shift interacts with cluster & trend signals (indirect confirmation) |

**Embedded Example:**
```ts
const recalcIndex = rows.findIndex(r => r.partitionId !== firstPartitionId);
expect(recalcIndex).toBeGreaterThan(-1);
expect(prevMean).not.toBe(newMean);
```

**Note:** Assertion focuses on structural recalculation (new partition & mean) rather than presence of pre-shift flags (which can vary with sequence design).

---

## 5. Assurance Icons (Capability vs Fallback)

**Behaviour:**
* Capability mode: Entire 3σ band above/below target → Pass/Fail else Uncertain.
* Fallback (single-point) mode when capability disabled or limits suppressed: point `>=` / `<=` target depending on direction.

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.recalcCrossingBoundary.client.test.ts` | Boundary equality: value exactly at target → Pass (Up metric fallback) |

**Embedded Example:**
```ts
expect(last.assuranceIcon).toBe(AssuranceIcon.Pass); // value === target in Up metric fallback
```

---

## 6. Mixed Signal Precedence

**Behaviour:** Combined scenario verifying coexistence & correct prioritisation / gating:
* Below-mean increasing trend (no premature Improvement)
* High-side cluster: four-of-five + shift (Improvement)
* Final extreme opposite side: Concern overrides local context for that row only

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.mixedPrecedence.client.test.ts` | Full integrated scenario (with & without cluster collapse) |

**Embedded Example:**
```ts
expect(anyImprovementInBelowTrend).toBe(false); // gating
expect(clusterRows.some(r=> r.variationIcon === VariationIcon.Improvement)).toBe(true);
expect(last.specialCauseSinglePointBelow).toBe(true);
expect(last.variationIcon).toBe(VariationIcon.Concern);
```

---

## 7. Rule Tags Provenance

**Behaviour:** `ruleTags` capture original raw rule detections prior to heuristic mutation (e.g., cluster collapse) for diagnostics.

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.ruleTags.persistence.client.test.ts` | Collapsed rows retain both `four_of_five_high` & `two_of_three_high` in ruleTags |

**Embedded Example:**
```ts
expect(after.ruleTags).toEqual(expect.arrayContaining(['four_of_five_high','two_of_three_high']));
```

---

## 8. Edge / Defensive Trend Cases

**Scenarios:**
* Alternating equal/above mean sequence – prevents false shift or trend.
* Equal-to-mean interruptions reset strict monotonic trend windows.
* Mixed-direction partial trends do not emit concern/improvement erroneously.

**Tests:** (see Trend Gating table – files `trendAlternatingMixed`, `trendCrossMeanEdge`, `trendEdgeCases`).

**Embedded Example (alternating neutralisation):**
```ts
expect(alternatingRows.every(r => !r.specialCauseShiftHigh && !r.specialCauseTrendIncreasing)).toBe(true);
```

---

## 9. Regression: ED 4h Compliance Misclassification

**Issue:** Early favourable classification due to ungated trend while values still below mean.

**Test:** `spc.ed4h.debug.test.ts` – asserts trend gating blocks premature Improvement; includes arrays of point-level flags for forensic output.

**Embedded Example:**
```ts
const improvements = rows.map(r => r.variationIcon === VariationIcon.Improvement);
// Assert no improvement prior to actual mean-cross / qualifying high-side signal
expect(improvements.slice(0, anomalyIndex).some(Boolean)).toBe(false);
```

---

## 10. Symmetry Validation (High vs Low)

**Goal:** Guarantee logic parity for both sides of the mean (no directional bias).

**Tests:**
| File | Coverage |
| ---- | -------- |
| `spc.twoOfThreeExclusion.lowSide.client.test.ts` | Low-side 2-of-3 exclusion symmetrical to high-side |
| `spc.fourOfFiveSymmetry.client.test.ts` | Low-side four-of-five + collapse parity |

**Embedded Example:**
```ts
expect(lowSideFlags.filter(Boolean).length).toBeGreaterThanOrEqual(4); // four-of-five below
```

---

## 11. Precedence Logic (Legacy vs Directional First) – Historical Reference

**File:** `spc.precedence.logic.test.ts`

Although newer gating reduced need for an alternate precedence strategy, the test preserves comparison to ensure no regression should directional heuristics be reintroduced.

**Embedded Example:**
```ts
expect(legacyConcernIndices.length).toBeGreaterThan(0);
expect(directionalConcernIndices.length).toBeLessThanOrEqual(legacyConcernIndices.length);
```

---

## 12. Future Opportunities

| Potential Addition | Rationale |
| ------------------ | --------- |
| Combined shift + target assurance case | Validate Pass after recalculation stability |
| Ghost point influence isolation | Explicit test for ghost gap handling in multi-point rules |
| Performance micro-benchmark | Safeguard algorithmic complexity across partitions |

---

## 13. Quick Reference Matrix

| Behaviour | High Side | Low Side | Mixed | Provenance | Recalc | Assurance |
| --------- | --------- | -------- | ----- | ---------- | ------ | --------- |
| Trend gating | ✓ | ✓ | ✓ | – | – | – |
| 2-of-3 exclusion | ✓ | ✓ | ✓ | ✓ (tags) | – | – |
| 4-of-5 rule | ✓ | ✓ | ✓ | ✓ (tags) | – | – |
| Cluster collapse | ✓ | ✓ | ✓ | ✓ | – | – |
| Shift detection | (indirect) | (symm potential) | ✓ | – | ✓ | – |
| Auto recalculation | – | – | ✓ | – | ✓ | – |
| Assurance fallback | – | – | – | – | – | ✓ |
| Single-point 3σ | ✓ | ✓ | ✓ | – | – | – |

---

## 14. Validation Summary

All critical SPC special-cause patterns have:
* Direct unit tests (favourable & adverse sides where applicable)
* Edge case protection (trend interruptions, exclusion logic)
* Provenance retention via `ruleTags` for diagnostic introspection

This suite aims to minimise accidental semantic regressions during future optimisation or heuristic refinement.

---

### Appendix: Minimal Pattern Construction Recipe

```ts
// Baseline stabilisation (ensures reliable sigma estimates)
const baseline = Array.from({length: 60}, (_,i)=> [100,101,99][i%3]);

// High-side mid-band cluster (2-of-3): pick values in (u2, u3)
const mid1 = u2 + (u3-u2)*0.3;
const mid2 = u2 + (u3-u2)*0.6;

// Extreme >3σ (single point only)
const extreme = u3 + (u3-u2)*0.5;
```

---

_End of document._

---

## 15. Baselines & Recalculation Mechanics

Why it matters: Correct segmentation (manual baseline flags, auto-recalculation after sustained shifts) prevents dilution of new process performance and avoids false special-cause carry‑over.

Tests & Rationale:
* `spc.baseline.client.test.ts` – Verifies manual `baseline:true` rows split partitions and means diverge; guards against accidental "extend baseline" regression.
* `spc.autoRecalc.client.test.ts` – Ensures optional automatic baseline insertion after a qualifying shift; also checks delta-sigma threshold gating (prevents noisy micro-shifts forcing recalculation).
* `spc.recalcCrossingBoundary.client.test.ts` – Confirms recalculation triggers only after configured sustained length and that new partition mean differs; also re‑asserts assurance boundary equality edge.
* `spc.baselineWarning.client.test.ts` – Emits `baseline_with_special_cause` warning when a baseline is placed on an outlier, prompting data quality / analyst review.
* `spc.baselineSuggest.client.test.ts` – Heuristic suggestion scoring (Shift / Trend / Point reasons) to guide users where recalculation may stabilise interpretation; noise case confirms low false‑positive rate.

## 16. Assurance Icons (Capability & Fallback) – Expanded

Why it matters: Communicates process capability vs simple latest-point attainment; incorrect logic biases assurance dashboards.

Additional Tests:
* `spc.assurance.client.test.ts` – Full matrix of Pass/Fail/None for Up/Down/Neither directions using band vs target spatial relationship.
* `spc.assurance.fallback.client.test.ts` – Distinguishes capability mode (band entirely favourable) from fallback (latest point on favourable side) ensuring graceful degradation when limits suppressed.

## 17. Minimum Points Threshold & Suppression

Why it matters: XmR statistical constants unreliable with insufficient points; early limit drawing inflates false signals.

* `spc.threshold.client.test.ts` – Guards 12/13 point boundary (&lt;=12 hides limits & icons, &gt;=13 enables) preventing regression that might surface premature limits.

## 18. Data Integrity & Hygiene (Null, Ghost, Moving Range)

Why it matters: Inclusion of nulls, ghost placeholders, or MR outliers distorts sigma and cascades into every special-cause rule.

* `spc.nullGhost.client.test.ts` – Ensures nulls excluded from numerator/denominator; ghost points retained visually but excluded from MR and mean; warning coverage (`null_values_excluded`).
* `spc.rareEventGhost.client.test.ts` (G & T) – Rare-event charts treat large gap outliers as ghosted events; validates pointRank semantics (ghost rank=0) and `ghost_rows_rare_event` warning payload.
* `spc.mrOutlier.client.test.ts` – Verifies optional exclusion tightens limits (span reduction) without widening; protects sensitivity improvement feature.

## 19. Cap Suppression (Performance / UX Safety)

Why it matters: Extremely long partitions widen limits gradually; capping limits computational cost and preserves interpretability.

* `spc.capSuppression.client.test.ts` – Partition cap, global cap, and combined sequence each emit correct warnings and null out statistics post cap boundary.

## 20. Cluster & Precedence Nuances – Additional Tests

Beyond sections 2 & 3:
* `spc.precedence.logic.test.ts` – Demonstrates legacy vs directional-first strategy (historical comparison) + explicit cluster collapse verification (overlap enforcement baseline dataset).
* `spc.comparativeHeuristics.logic.test.ts` – Confirms legacy heuristic suppression removed (both early adverse and later favourable shifts retained) preventing silent rule masking.
* `spc.ruleClash.client.test.ts` & `spc.ruleClashHigh.client.test.ts` – Low and high side simultaneous shift+trend backfill behaviour; ensures consistent multi-flag propagation over the qualifying window.
* `spc.conflictInvariant.client.test.ts` – Proves impossible to get conflicting (simultaneous high & low) signals on one row; guards invariants after rule engine refactors.

## 21. Variation Icon Semantics – Orthodoxy Matrix

Why it matters: Icons drive end-user interpretation; any direction/inversion mistake misleads improvement focus.

* `spc.variationIcons.client.test.ts` – Exhaustive single 3σ point classification across Up/Down/Neither directions; neutral invariance ensures policy neutrality for metrics without defined direction.

## 22. Snapshot / Golden Parity & Statistical Fidelity

Why it matters: Protects numerical stability (floating tolerance) of sigma, limits, MR-bar across refactors and library upgrades.

* `spc.golden.client.test.ts` – External CSV parity (mean, MR-bar, limits) with tolerance; validates deterministic reproduction of published reference dataset.
* `spc.golden.snapshot.client.test.ts` – Multi-chart (XmR, G, T) full-row JSON projection verifying every rule flag + zone boundary; single source fails fast if algorithm drifts.

## 23. Provenance & Rule Tag Integrity – Extended

Supplements section 7:
* `spc.provenance.client.test.ts` – Ensures only raw rule tags emitted (no deprecated heuristic prefixes) simplifying downstream analytics filter logic.
* `spc.ruleTags.persistence.client.test.ts` – Confirms cluster collapse never erases historical rule evidence (two-of-three tags retained) maintaining audit trail.

## 24. Mixed / Integrated Scenario – Already Covered

* `spc.mixedPrecedence.client.test.ts` – Serves as integration smoke for gating, collapse, precedence, and divergent final opposite-side signal.

## 25. Backfill Diagnostics (Non-Normative)

Why it matters: Internal guard that retroactive propagation of shift/trend flags remains consistent; outputs logged only when discrepancies found.

* `spc.backfillDiagnostics.test.ts` – Enumerates scenarios and reports (does not fail) missing backfill instances; lightweight early warning without blocking CI.
* `spc.singlePointEndsDiagnostics.test.ts` – Surface-level logging harness for edge windows (debug regression reproduction).
* Placeholders `spc.colourActual.temp.test.ts`, `spc.temp.diagnostic.test.ts` – Intentional no-op to keep suite structural placeholders until replaced.

## 26. Additional / Legacy Regression Guards

* `__tests__/spc.ed4h.debug.test.ts` – Real-world metric reproduction ensuring gating prevented previously observed premature classification.
* `spc.trendCrossMeanEdge.client.test.ts`, `spc.trendAlternatingMixed.client.test.ts`, `spc.trendEdgeCases.client.test.ts` – Collectively enforce monotonic + cross-mean + neutralisation semantics beyond primary gating test, reducing accidental simplified trend logic regressions.

## 27. Requirement–Test Mapping (Completeness Review)

| Requirement Domain | Covered Tests (Primary) | Status |
| ------------------- | ----------------------- | ------ |
| Single-point 3σ | variationIcons, golden, snapshot | ✓ |
| Two-of-three (exclusion) | twoOfThreeExclusion*, mixedPrecedence, fourOfFiveSymmetry (collapse overlap) | ✓ |
| Four-of-five 1σ | fourOfFiveSymmetry, fourOfFive, mixedPrecedence | ✓ |
| Cluster collapse | fourOfFiveSymmetry, ruleTags.persistence, precedence.logic | ✓ |
| Shift detection | mixedPrecedence, precedence.logic, autoRecalc, baselineSuggest | ✓ |
| Trend detection & gating | trendSideGate, trendEdgeCases, trendCrossMeanEdge, trendAlternatingMixed, mixedPrecedence | ✓ |
| Assurance (capability & fallback) | assurance.client, assurance.fallback, recalcCrossingBoundary | ✓ |
| Minimum points suppression | threshold.client | ✓ |
| Baseline manual partition | baseline.client | ✓ |
| Auto recalculation | autoRecalc, recalcCrossingBoundary | ✓ |
| Baseline warnings & suggestions | baselineWarning, baselineSuggest | ✓ |
| Data hygiene (null/ghost) | nullGhost, rareEventGhost | ✓ |
| MR outlier exclusion | mrOutlier.client | ✓ |
| Caps (partition/global) | capSuppression.client | ✓ |
| Invariant (no dual-side clash) | conflictInvariant.client | ✓ |
| Rule clash (shift+trend) | ruleClash, ruleClashHigh | ✓ |
| Provenance / rule tags | provenance.client, ruleTags.persistence | ✓ |
| Precedence strategies | precedence.logic, comparativeHeuristics.logic | ✓ |
| Integrated scenario | mixedPrecedence | ✓ |
| Golden statistical fidelity | golden.client, golden.snapshot | ✓ |
| Rare-event charts (G/T) basics | rareEventGhost, golden.snapshot | ✓ (future deep tests noted) |
| Diagnostic non-blocking | backfillDiagnostics, singlePointEndsDiagnostics | ✓ |

## 28. Identified Potential Future Enhancements

| Gap Candidate | Justification | Suggested Test Idea |
| ------------- | ------------- | ------------------- |
| Dedicated multi-point rule tests for G & T charts | Snapshot covers but no isolated behavioural unit tests | Craft synthetic G/T series triggering trend / shift analogues & ghost interactions |
| Performance regression guard | Ensure O(n) scaling under large partitions | Micro-benchmark comparing limit calc time for 1k vs 10k points |
| Baseline suggestion precision metrics | Quantify precision/recall vs curated analyst labels | Include labelled scenarios set evaluating suggestion reasons & scores |
| Assurance + recalculation interplay | Post-recalc capability evaluation stability | Dataset with two sequential shifts and target verifying pass/fail transitions |

Current judgement: Core SPC interpretive semantics are comprehensively covered; remaining items are value-add rather than correctness blockers.

---

### Appendix B: Test Classification Legend

* Primary: Directly enforces domain rule semantics.
* Integration: Combines multiple primary behaviours (guards unintended interaction regressions).
* Regression: Locks a previously observed production bug.
* Diagnostic: Non-failing early warning / logging harness.

---

All presently implemented SPC rule, hygiene, partitioning, assurance, and provenance requirements have at least one deterministic automated test. No untested mandatory rule logic identified during this audit.

